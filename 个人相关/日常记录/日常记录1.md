#  19/5-6：

### 请简述 LinkedHashMap 的工作原理和使用方式？

​	LinkedHashMap 是继承自 HashMap 实现Map接口，

​	LinkedHashMap 和 HashMap 的主要区别就是 LinkedHashMap 是有序的，而 HashMap 是无序的。

​	LinkedHashMap 默认为插入的顺序，他是基于HashMap 和 双向链表实现的，LinkedHashMap 是线程不安全的。

### AsyncTask 启动的方式？

​	在SDK3.0以前的版本执行 asyncTask.execute(task)  时的确是多线程并发执行的，线程池大小为5，最大128个，google 在3.0以后做了修改 ，将 asyncTask.execute(task）修改为了顺序执行，即只有当一个任务完成后才执行下一个任务

​	那么怎么并发执行呢？很简单，3.0后新增了一个方法  executeOnExecutor(Executor exec ,Object... params)，该方法接收两个参数，第一个是 Executor ，第二个是任务参数，第一个是线程池实例，google 为我们定义了两种，第一种是AsyncTask.SERIAL_EXECUTOR ，第二种是AsyncTask.THREAD_POOL_EXECUTOR，顾名思义，第一种就是3.0 以后的方法，是顺序执行的，第二种就是3.0以前的 execute 方法，是可以并发执行的，我们直接用asyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, task);就可以多任务并发执行了。

​	自定义Executor

```java
private static ExecutorService exec = Executors.newSingleThreadExecutor();

//程序在每次调用时是使用的同一个Executor，
syncTask.executeOnExecutor(exec, task);

//当Executor类型为下面时 只有两个线程在执行任务
private static ExecutorService exec = Executors.newFixedThreadPool(2);
syncTask.executeOnExecutor(exec, task);

```

# 19/5-7

### 谈一谈JAVA 的垃圾回收机制？

垃圾回收机制：
当堆内存中的某块区域没有对象引用时，这个内存区域就会变成垃圾，等待垃圾回收器的回收，

怎么找到无用对象：

- 引用计数：最简单的寻找无用对象的机制，当一个对象被引用一次，引用计数+1，当失去引用时引用计数-1，当此对象引用计数为0时可以直接回收。这种方法有一个显而易见的问题：无法回收被循环引用的对象。
- 可达性分析：从一个根对象(GC Root)开始向下搜寻，可以认为搜寻到的所有有强引用的对象都是活跃对象，所有找不到的对象都是无用对象，无用对象可能会被即刻回收，也可能进行其他操作（比如执行对象的finalize()方法）
  这里还会引出一点问题：关于强引用，软引用，弱引用和虚引用的分别处理，具体可以看

强制垃圾回收：
程序只能控制一个对象不被任何引用变量引用，绝对不能控制它的回收。
System.gc();
Runntime.getTuntime().gc();
上面两个方法会建议系统进行垃圾回收，但是系统也有可能不进行回收。
对象的复活可以通过 finalize()方法来实现，

### android ButterKnife 依赖

​	1，如果项目只有一个 主module ，则依赖添加如下：

​		在module 的build.gradle 中添加如下

```java
api 'com.jakewharton:butterknife:8.4.0'
annotationProcessor 'com.jakewharton:butterknife-compiler:8.4.0'
```

​		在项目的 build.gradle 中添加:

```java
dependencies {
    //noinspection GradleDependency
    classpath 'com.android.tools.build:gradle:3.2.0'
     //ButterKnife 依赖
    classpath 'com.jakewharton:butterknife-gradle-plugin:8.4.0'
}
```

​	2，如果在library中使用，则需要给library的 build.gradle 中添加如下:

```java
apply plugin: 'com.android.library'
    
api 'com.jakewharton:butterknife:8.4.0'
    //noinspection GradleDependency
annotationProcessor 'com.jakewharton:butterknife-compiler:8.4.0'
```

​	在项目的 build.gradle 中添加:

```java
dependencies {
    //noinspection GradleDependency
    classpath 'com.android.tools.build:gradle:3.2.0'
     //ButterKnife 依赖
    classpath 'com.jakewharton:butterknife-gradle-plugin:8.4.0'
}
```

使用注意：

​	第一步为 绑定ButterKnife，

​	如果是一个 主module 中使用，则可以直接使用R来调用资源文件，但是如果在 library 中使用，则需要使用R2 来调用资源文件.

### 设置一个单选对话框：

```java
private String[] mGenders = new String[]{"男","女","保密"};
getGenderDialog(new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        final AppCompatTextView textView = view.findViewById(R.id.tv_arrow_value);
                        textView.setText(mGenders[which]);
                    }
                });
 //设置一个单选对话框
 private void getGenderDialog(DialogInterface.OnClickListener listener){
        final AlertDialog.Builder builder = new AlertDialog.Builder(DELEGATE.getContext());
        builder.setSingleChoiceItems(mGenders,0,listener);
        builder.show();
    }
```

# 19/5-9

###  	类加载过程

​	类加载的过程分为三个部分： 

​	1，加载 类加载是将.class 文件中的二进制数据读入内存中，将其放在运行时数据区的方法区内，然后在堆内存中创建一个对象，又来封装类在方法区内的数据接口。类加载的最终产品是为与堆中的Class 对象。

​	 2，类的连接 类加载完成后，就会进入连接阶段，连接阶段负责把类的二进制数据合并到jre中，可分为三个阶段 

​		1，验证。

​		 2，准备。

​		 3，解析。

​	 3，类的初始化 在类的初始化阶段，虚拟机负责对类进行初始化，主要是对类变量进行初始化。JVM初始化一个类包含如下几个步骤 

​		1,假如这个类没有被加载和连接，则程序加载并连接该类。

​		2,假如该类的直接父类还没有被初始化，则先初始化其直接父类。 

​		3,假如类中有初始化语句，则系统一次执行这些初始化语句。 

### 	谈谈如果优化ListView

​	1，在适配器中尽量少使用逻辑

​		不要在getView()中写过多的逻辑代码。

​	2，GC垃圾回收器

​		当创建了大量的对象时，GC就会频繁的运行，所以在getView() 方法中不要创建非常多的对象。假设你的 log 里		  面发现“GC has freed dome memory”频繁出现，那么程序肯定有问题了。

​		你可以检查一下：

​			1，item 布局的层级是否太深。

​			2，getView()方法是否有大量对象存在。

​			3，ListView 的布局属性。

​	3，载入图片

​		如果你的ListView 必须要从网络上下载图片，我们不要在 ListView 滑动的时候加载图片，那样会让ListView 变得卡顿，所以我们要监听ListView 的状态，在滑动的时候 停止载入图片，没有滑动在 开始载入图片。

```java
listView.setOnScrollListener(new OnScrollListener() {

            @Override
            public void onScrollStateChanged(AbsListView listView, int scrollState) {
                    //停止载入图片 
                    if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_FLING) {
                            imageLoader.stopProcessingQueue();
                    } else {
                    //開始载入图片
                            imageLoader.startProcessingQueue();
                    }
            }

            @Override
            public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
                    // TODO Auto-generated method stub

            }
    });
```

​	4,将 ListView 的 scrollingCache 和 animateCache 设置为false

​	**scrollingCache:** scrollingCache本质上是drawing cache，你能够让一个View将他自己的drawing保存在cache中（保存为一个bitmap），这样下次再显示View的时候就不用重画了，而是从cache中取出。默认情况下drawing cahce是禁用的。由于它太耗内存了，可是它确实比重画来的更加平滑。

​	而在ListView中，scrollingCache是默认开启的，我们能够手动将它关闭。

​	animateCache: ListView 默认开启了animateCache，这会消耗大量的内存，因此会频繁调用GC，我们能够手动将它关闭掉。

​	5，降低item的布局的深度

​	5，使用ViewHolder。

​    再次建议使用RecyclerView。

### 日期选择器 DatePicker 的封装

```java
public class DateDialogUtil {

    public interface IDateListener{
        void onDateChange(String date);
    }
    private String data = null;
    private IDateListener mDataListener = null;

    public void setDateListener(IDateListener listener){
        this.mDataListener = listener;
    }
    public void showDialog(final Context context){
        final LinearLayout ll = new LinearLayout(context);
        final DatePicker picker = new DatePicker(context);
        final LinearLayout.LayoutParams lp  = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT);
        picker.setLayoutParams(lp);
        picker.init(1990, 1, 1, new DatePicker.OnDateChangedListener() {
            @Override
            public void onDateChanged(DatePicker view, int year, int monthOfYear, int dayOfMonth) {
                final Calendar calendar = Calendar.getInstance();
                //设置时间
                calendar.set(year,monthOfYear,dayOfMonth);
                //日期格式化,使用此Java虚拟机实例的默认区域设置的当前值
                SimpleDateFormat format = new SimpleDateFormat("yyyy年MM月dd日",Locale.getDefault());
                data = format.format(calendar.getTime());
            }
        });
        ll.addView(picker);
        new AlertDialog.Builder(context)
                .setView(ll)
                .setPositiveButton("确定", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        if (mDataListener != null && data != null){
                            mDataListener.onDateChange(data);
                        }
                    }
                })
                .setNegativeButton("取消", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                })
                .show();
    }
}
```

```java
final DateDialogUtil dateDialogUtil = new DateDialogUtil();
dateDialogUtil.setDateListener(new DateDialogUtil.IDateListener() {
    @Override
    public void onDateChange(String date) {
        final TextView textView = view.findViewById(R.id.tv_arrow_value);
        textView.setText(date);
    }
});
```

# 19/5-10

### 	谈谈你对 Activity.runOnUiThread 的理解？

```java
 public final void runOnUiThread(Runnable action) {
        if (Thread.currentThread() != mUiThread) {
            mHandler.post(action);
        } else {
            action.run();
        }
    }
```

​	判断当前是不是 ui 线程，如果是就直接运行，否则就通过handler的post方法切换到主线程

### Android 权限的封装 

​	[权限的封装](https://blog.csdn.net/baidu_40389775/article/details/90051861)

### 注解权限：PermissionsDispatcher 的简单使用：

​	 @RuntimePermissions :这是必须使用的注解，用于标注你想要的申请权限的Activity或者Fragment，

```java
@RuntimePermissions
public abstract class PermissionCheckerDelegate extends Activity {
}
```

​	@NeedsPermission(Manifest.permission.CAMERA) ：

​	这个也是必须要使用的注解， 用于标注你需要获取权限的方法，注解括号里面有个参数，传入想要申请得权限，可以传入多个。当获得了对应的权限后就会执行这个方法。

```java
@NeedsPermission(Manifest.permission.CAMERA)
void startCamera() {
    LatteCamera.start(this);
}
```

​	@OnShowRationale(Manifest.permission.CAMERA) ：

​	这个不是必须的注解，用于标注申请权限 时需要执行的方法，传入想要申请的权限，还需要一个PermissionRequest对象，这个对象有两种方法  proceed()让权限继续请求，canncel()让请求中断。也就是说，这个方法会拦截你发出的请求，这个方法*  用于告诉你接下来申请权限是干啥的，说服用户给你权限

```java
  @OnShowRationale(Manifest.permission.CAMERA)
    void onCameraReational(PermissionRequest request) {
        showRetionaeDialog(request);
    }

    private void showRetionaeDialog(final PermissionRequest request) {
        new AlertDialog.Builder(getContext())
                .setPositiveButton("同意使用", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        request.proceed();
                    }
                })
                .setNegativeButton("拒绝使用", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        request.cancel();
                    }
                })
                .setCancelable(false)
                .setMessage("权限管理")
                .show();
    }
```

​	 @OnPermissionDenied注解：

​	这个也不是必须的注解，用于标注如果权限请求失败，  但是用户没有勾选不再询问的时候执行的方法，注解括号里面有参数，传入想要申请的权限。 也就是说，我们可以在这个方法做申请权限失败之后的处理，如像用户解释为什么要申请，或者重新申请操作等。

​	 onRequestPermissionsResult()方法

​	Rebuild 之后会生成一个辅助类，用来调用被注解的Activity的方法，所以，第一次使用的话*  注解添加完后 要Rebuild 一次。否则不能生成辅助类。

```java
用于储存已经被虚拟机加载的类信息、常量，静态变量等待
```

​	使用如下

```java
//调用该方法后就会申请权限，成功之后就会执行相应的代码
public void startCameraWithCheck() {
    PermissionCheckerDelegatePermissionsDispatcher.startCameraWithPermissionCheck(this);
}
```



### 封装一个全局的回调接口：

```java
public interface IGlobalCallback<T> {
    void executeCallBack(T args);
}
```

```java
public enum CallBackType {
    /**
     * 剪裁后的回调
     */
    ON_CROP
}
```

```java
public class CallbackManager {
    private static final WeakHashMap<Object,IGlobalCallback> CALLBACKS = new WeakHashMap<>();

    private static class Holder{
        private static final CallbackManager IINSTANCE = new CallbackManager();
    }
    public static CallbackManager getInstance(){
        return Holder.IINSTANCE;
    }

    public CallbackManager addCallback(Object tag ,IGlobalCallback callback ){
        CALLBACKS.put(tag,callback);
        return this;
    }
    public IGlobalCallback getCallBack(Object tag){
        return CALLBACKS.get(tag);
    }
}
```

//使用如下：

```java
	//实现
	CallbackManager.getInstance()
        .addCallback(CallBackType.ON_CROP, new IGlobalCallback<Uri>(){
            @Override
            public void executeCallBack(Uri args) {
                Log.e(TAG, "executeCallBack: "+args );
            }
        });

	//调用
	final IGlobalCallback<Uri> callback = CallbackManager
                            .getInstance()
                            .getCallBack(CallBackType.ON_CROP);
    if (callback != null){
            callback.executeCallBack(cropUri);
    }
```

调用手机相册，照相机，裁剪图片

​	[点击进行查看](https://blog.csdn.net/baidu_40389775/article/details/90066874)

# 19/5-11

### 	请列出几种常见的工厂模式，并说明他的用法？

​		[工厂模式](https://blog.csdn.net/baidu_40389775/article/details/88779940)

### 	问题：打开项目后文件名字都是J 开头，全部报红，xml 文件打开后乱码。解决办法：

​		经过查看，使用notepad 打开后发现一切正常，最后将项目换个位置。打开后一切正常

# 19/5-12

### 请说一下HashMap 和 HashTable 的区别？

​	1，HashMap 支持 null 键 和null值，而HashMap 在遇到null 是，会抛出 空指针异常。

​	2，我们说HashTable是同步的，HashMap不是，也就是说HashTable在多线程使用的情况下，不需要做额外的同步 

​	3， HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。 

​	4，HashTable 继承子Dictionary 类，二HashMap 继承AbstractMap 类，但是二者都实现了Map 接口

​	5， Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。 

# 19/6-4

谈谈 Error 和 Exception 的区别

	Error 是系统中的错误，不可预料的，这种异常发生后，会导致程序立即崩溃。只能通过修改代码，使错误不在出现，这种错误 无法被捕获。
	
	Exception 则是可以预料的。在程序中如果过感觉某段代码会出现 异常，则可以使用 try catch 进行捕获 ，或者直接抛出异常。Exception 可分为 编译时异常(CheckedException) 和 运行时异常(RuntimeException)。运行时异常可以 忽略捕获操作(RuntimeException)，编译时异常必须使用 try catch 进行捕获。 

### 常见的几种[RuntimeException](http://blog.csdn.net/qq635785620/article/details/7781026)如下：

NullPointerException - 空指针引用异常
ClassCastException - 类型强制转换异常。
IllegalArgumentException - 传递非法参数异常。
ArithmeticException - 算术运算异常
ArrayStoreException - 向数组中存放与声明类型不兼容对象异常
IndexOutOfBoundsException - 下标越界异常
NegativeArraySizeException - 创建一个大小为负数的数组错误异常
NumberFormatException - 数字格式异常
SecurityException - 安全异常
UnsupportedOperationException - 不支持的操作异常

算术异常类：ArithmeticExecption
空指针异常类：NullPointerException
类型强制转换异常：ClassCastException
数组负下标异常：NegativeArrayException
数组下标越界异常：ArrayIndexOutOfBoundsException
违背安全原则异常：SecturityException
文件已结束异常：EOFException
文件未找到异常：FileNotFoundException
字符串转换为数字异常：NumberFormatException
操作[数据库](http://lib.csdn.net/base/mysql)异常：SQLException
输入输出异常：IOException
方法未找到异常：NoSuchMethodException

java.lang.AbstractMethodError
抽象方法错误。当应用试图调用抽象方法时抛出。
java.lang.AssertionError
断言错。用来指示一个断言失败的情况。
java.lang.ClassCircularityError
类循环依赖错误。在初始化一个类时，若检测到类之间循环依赖则抛出该异常。
java.lang.ClassFormatError
类格式错误。当Java虚拟机试图从一个文件中读取Java类，而检测到该文件的内容不符合类的有效格式时抛出。
java.lang.Error
错误。是所有错误的基类，用于标识严重的程序运行问题。这些问题通常描述一些不应被应用程序捕获的反常情况。
java.lang.ExceptionInInitializerError
初始化程序错误。当执行一个类的静态初始化程序的过程中，发生了异常时抛出。静态初始化程序是指直接包含于类中的static语句段。
java.lang.IllegalAccessError
违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。
java.lang.IncompatibleClassChangeError
不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。
java.lang.InstantiationError
实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.
java.lang.InternalError
内部错误。用于指示Java虚拟机发生了内部错误。
java.lang.LinkageError
链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。
java.lang.NoClassDefFoundError
未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。
java.lang.NoSuchFieldError
域不存在错误。当应用试图访问或者修改某类的某个域，而该类的定义中没有该域的定义时抛出该错误。
java.lang.NoSuchMethodError
方法不存在错误。当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误。
java.lang.OutOfMemoryError
内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。
java.lang.StackOverflowError
堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误。
java.lang.ThreadDeath
线程结束。当调用Thread类的stop方法时抛出该错误，用于指示线程结束。
java.lang.UnknownError
未知错误。用于指示Java虚拟机发生了未知严重错误的情况。
java.lang.UnsatisfiedLinkError
未满足的链接错误。当Java虚拟机未找到某个类的声明为native方法的本机语言定义时抛出。
java.lang.UnsupportedClassVersionError
不支持的类版本错误。当Java虚拟机试图从读取某个类文件，但是发现该文件的主、次版本号不被当前Java虚拟机支持的时候，抛出该错误。
java.lang.VerifyError
验证错误。当验证器检测到某个类文件中存在内部不兼容或者安全问题时抛出该错误。
java.lang.VirtualMachineError
虚拟机错误。用于指示虚拟机被破坏或者继续执行操作所需的资源不足的情况。

java.lang.ArithmeticException
算术条件异常。譬如：整数除零等。
java.lang.ArrayIndexOutOfBoundsException
数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。
java.lang.ArrayStoreException
数组存储异常。当向数组中存放非数组声明类型对象时抛出。
java.lang.ClassCastException
类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。
java.lang.ClassNotFoundException
找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。
java.lang.CloneNotSupportedException
不支持克隆异常。当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。
java.lang.EnumConstantNotPresentException
枚举常量不存在异常。当应用试图通过名称和枚举类型访问一个枚举对象，但该枚举对象并不包含常量时，抛出该异常。
java.lang.Exception
根异常。用以描述应用程序希望捕获的情况。
java.lang.IllegalAccessException
违法的访问异常。当应用试图通过反射方式创建某个类的实例、访问该类属性、调用该类方法，而当时又无法访问类的、属性的、方法的或构造方法的定义时抛出该异常。
java.lang.IllegalMonitorStateException
违法的监控状态异常。当某个线程试图等待一个自己并不拥有的对象（O）的监控器或者通知其他线程等待该对象（O）的监控器时，抛出该异常。
java.lang.IllegalStateException
违法的状态异常。当在Java环境和应用尚未处于某个方法的合法调用状态，而调用了该方法时，抛出该异常。
java.lang.IllegalThreadStateException
违法的线程状态异常。当县城尚未处于某个方法的合法调用状态，而调用了该方法时，抛出异常。
java.lang.IndexOutOfBoundsException
索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。
java.lang.InstantiationException
实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。
java.lang.InterruptedException
被中止异常。当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。
java.lang.NegativeArraySizeException
数组大小为负值异常。当使用负数大小值创建数组时抛出该异常。
java.lang.NoSuchFieldException
属性不存在异常。当访问某个类的不存在的属性时抛出该异常。
java.lang.NoSuchMethodException
方法不存在异常。当访问某个类的不存在的方法时抛出该异常。
java.lang.NullPointerException
空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。
java.lang.NumberFormatException
数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。
java.lang.RuntimeException
运行时异常。是所有Java虚拟机正常操作期间可以被抛出的异常的父类。
java.lang.SecurityException
安全异常。由安全管理器抛出，用于指示违反安全情况的异常。
java.lang.StringIndexOutOfBoundsException
字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。
java.lang.TypeNotPresentException
类型不存在异常。当应用试图以某个类型名称的字符串表达方式访问该类型，但是根据给定的名称又找不到该类型是抛出该异常。该异常与ClassNotFoundException的区别在于该异常是unchecked（不被检查）异常，而ClassNotFoundException是checked（被检查）异常。
java.lang.UnsupportedOperationException
不支持的方法异常。指明请求的方法不被支持情况的异常。

### 谈谈Thread 中 run() 和 start() 的区别

	run() 和普通的成员方法一样，可以被重复调用。但是如果单独调用 run 方法，则不是在子线程中执行。
	
	start() 这个方法只能被调用一次。调用这个方法后 程序会启动一个 新的线程来 执行 run 方法。注意 ：调用start 后，线程处于可运行状态(并没有运行)，一旦得到 cup 时间片，就开始执行run 方法，run 方法结束后，线程则立即终止。

# 19/6-5

### 获取当前View 位于屏幕的位置，

```java
	    int[] pos = new int[2];
        getLocationInWindow(pos); //获取位于屏幕的位置 保存到 数组中
		//获取距离四条边的位置
        rect.left = pos[0];
        rect.top = pos[1];
        rect.right = pos[0]+getWidth();
        rect.bottom = pos[1]+getHeight();
```
### android 中 图片的优化方案？

没有 详细的了解过。记录一下：<https://blog.csdn.net/u012124438/article/details/66087785> 

# 19/6-11

### 请简述 Http 和 Https 的区别

1，http 协议传输的数据都是未加密的，也就是明文的。因此使用 http 协议传输隐私信息非常不安全，为了保证信息的安全性，所以 诞生了 https

2，https 协议需要到 ca 申请证书，一般免费证书比较少，因而需要一定的费用。

3，http 是超文本传输协议，信息是明文传输， https 则是具有加密的传输协议。

4，http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

5，http 的连接非常简单，是没有状态的；https 是由 SSL + HTTP 协议够贱的可进行加密传输，身份认证的网络协议，比http 安全。

如果在 android 9.0 上使用 http 进行传输，需要在 application 下设置 

```java
android:usesCleartextTraffic="true"
```

### 说说 项目中用到的设计模式 和 使用场景

	经常用到的 就是 单例模式 ，工厂模式 ，建造者模式，代理模式等。
	
	很多时候设计模式为了整体代码更加系统性，有时候我们编码肯能不会特意去思考该用什么设计模式，但有时候又无意间使用了。对于安卓项目多多看看安卓Frameworks源码设计 可以学习很多优秀的设计模式， 
	
	一个软件的设计的稳定性取决于 -高内聚，低耦合，实际编码中我们可以在自己重构项目的过程中一步步使用设计模式。 

### 利用系统的 API 进行 dp 和 px 的转换

```java
//将50dp转为px

int defaultMargin = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,50,getResources().getDisplayMetrics());
```

### 视图动画：LayoutAnimation

	layoutAnimation 使用的还是比较多，他可以赋予页面一种展开的效果，当前，他也是有限制的，只能给子View 统一的动画效果，
	
	它使用起来非常简单，有两种方式，分别是 xml 和 代码。

步骤：

	1，先写一个 补间动画
	
	2，在写一个专门的 layoutAnimation.xml 文件
	
	3，最后给根节点的 ViewGroup 设置上 自定义的 layoutAnimation

如下所示：

	补间动画:

```java
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <rotate
        android:fromDegrees="0"
        android:interpolator="@android:anim/accelerate_decelerate_interpolator"
        android:pivotX="50%"
        android:pivotY="50%"
        android:duration="1000"
        android:toDegrees="+360" />
</set> 
```

	layoutAnimation.xml 文件

```java
<layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android"
    android:animation="@anim/rotate"
    android:animationOrder="normal"
    android:delay="0.3"/>

<!-- animation 是指定动画
     animationOrder 是子元素的动画顺序有三种选项
                    normal 表示顺序显示
                    reverse 表示逆向显示
                    random 表示随机播放入场动画
     delayp 是子元素开始动画的事件延迟，比如子元素入场动画
     的周期为 300ms ，那么0.5 就代表每一个子元素要延迟
     150ms 才能播放入场动画。总的来时 ，第一个子元素延迟
     150ms 播放动画，第二个就是 300ms 播放动画，依次类推-->
```

	上面两个动画都写在 anim 文件夹下
	
	最后直接使用

```java
<com.admin.view_core.viewGroup.CustomContainer
    android:id="@+id/container"
    android:layout_width="300dp"
    android:layout_height="300dp"
    android:layoutAnimation="@anim/layout_animation"
    android:background="#999999">
    .......
```

效果如下：

![ObjectAnimator](F:\笔记\日记\assets/ObjectAnimator-1560313411538.gif)

这个只是 旋转了一下 ，平移，移动 等 都可以做

使用 代码完成：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    final CustomContainer container = findViewById(R.id.container);
    container.post(new Runnable() {
        @Override
        public void run() {
            Animation animation = AnimationUtils.loadAnimation(MainActivity.this,R.anim.rotate);
            LayoutAnimationController controller = new LayoutAnimationController(animation);
            controller.setDelay(0.3f);
            controller.setOrder(LayoutAnimationController.ORDER_NORMAL);

            container.setLayoutAnimation(controller);
            container.setLayoutAnimationListener(new Animation.AnimationListener() {
                @Override
                public void onAnimationStart(Animation animation) {

                }
                @Override
                public void onAnimationEnd(Animation animation) {
                    Toast.makeText(MainActivity.this,"结束",Toast.LENGTH_LONG).show();
                }
                @Override
                public void onAnimationRepeat(Animation animation) {

                }
            });
        }
    });

}
```

动画效果 和上面一样

### 谈谈对 ConcurrentHashMap 的理解：

	ConcurrentHashMap 是线程安全的 map ，内部采用了分段锁的概念，每一个分段都持有者一个锁。因为他不是像HashTable 每个方法都加 synchronized ,所以比起 HashTable 他是高效的，比起HashMap 他是安全的。

# 19/6-14

### 谈一谈 Java 中的深拷贝 与 浅拷贝 的区别，并实现他们

浅拷贝：

	1，被拷贝的类 需要实现 Clonenable 接口(不实现的话在 调用 clone 方法会抛出CloneNotSupportedException 异常)，该接口为标记接口，不包含任何方法
	
	2，覆盖 clone() 方法，访问修饰符设置为 public ，方法中调用 super.clone()方法得到 需要复制的对象,(native 为本地方法)

```java
public class Student implements Cloneable {
    public String name;
    public Address address;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    /**
     * 浅拷贝
     */
    @Override
    public Object clone()  {
        Student student = null;
        try {
            student = (Student) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return student;
    }

    public static void main(String[] args){
        Student stu1 = new Student();
        stu1.setName("张三");
        stu1.setAddress(new Address("北京"));
        Student stu2 = (Student) stu1.clone();
        System.out.println("学生1"+stu1.getName());
        System.out.println("学生1"+stu1.getAddress().getAddr());
        System.out.println("学生2"+stu2.getName());
        System.out.println("学生2"+stu2.getAddress().getAddr());
        System.out.println("----------------------------");
        //修改学生2的姓名 和 地址
        stu2.setName("李四");
        stu2.getAddress().setAddr("上海");
        System.out.println("学生1"+stu1.getName());
        System.out.println("学生1"+stu1.getAddress().getAddr());
        System.out.println("学生2"+stu2.getName());
        System.out.println("学生2"+stu2.getAddress().getAddr());
    }
}
class Address{
    private String addr;
    Address(String addr) {
        this.addr = addr;
    }
    String getAddr() {
        return addr;
    }
    void setAddr(String addr) {
        this.addr = addr;
    }
}

```

结果如下：

```
学生1张三
学生1北京
学生2张三
学生2北京
----------------------------
学生1张三
学生1上海
学生2李四
学生2上海
```

从结果可以 看出 ，进行浅拷贝后 ，该对象的被复制了一份，但是注意，当修改 学生2 的姓名和地址后，发现 姓名是对的。但是 学生1 的地址和 学生2 的地址变成了同一个。这就说明 **浅拷贝如果拷贝基本类型 ，拷贝的就是基本类型的值，如果是 引用类型，则拷贝的是地址。**

深拷贝：

	深拷贝 会拷贝所有的属性，并拷贝所有的属性 指向动态分配的内存，深拷贝 相比于将拷贝 花销大且速度较慢。

通过序列化的方式进行深拷贝

```java
public class Student implements Cloneable, Serializable {
    public String name;
    public Address address;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    /**
     * 深拷贝
     */
    @Override
    public Object clone() {
        Student student = null;
        try {
            //将输出流 的数据写入数组
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream out = new ObjectOutputStream(bos);
            out.writeObject(this);
            out.close();
            bos.close();

            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
            ObjectInputStream in = new ObjectInputStream(bis);
            student = (Student) in.readObject();
            in.close();
            bis.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return student;
    }

    public static void main(String[] args) {
        Student stu1 = new Student();
        stu1.setName("张三");
        stu1.setAddress(new Address("北京"));
        Student stu2 = (Student) stu1.clone();
        System.out.println("学生1" + stu1.getName());
        System.out.println("学生1" + stu1.getAddress().getAddr());
        System.out.println("学生2" + stu2.getName());
        System.out.println("学生2" + stu2.getAddress().getAddr());
        System.out.println("----------------------------");
        //修改学生2的姓名 和 地址
        stu2.setName("李四");
        stu2.getAddress().setAddr("上海");
        System.out.println("学生1" + stu1.getName());
        System.out.println("学生1" + stu1.getAddress().getAddr());
        System.out.println("学生2" + stu2.getName());
        System.out.println("学生2" + stu2.getAddress().getAddr());
    }
}

class Address implements Serializable {
    private String addr;

    Address(String addr) {
        this.addr = addr;
    }

    String getAddr() {
        return addr;
    }

    void setAddr(String addr) {
        this.addr = addr;
    }
}
```

结果如下：

```java
学生1张三
学生1北京
学生2张三
学生2北京
----------------------------
学生1张三
学生1北京
学生2李四
学生2上海

```

可以看到通过 序列化的方式 可以进行深度的拷贝

如何选择：

如果对象的属性都是基本类型，则可以使用浅拷贝。如果对象有引用属性，那么就基于具体的需求来选择是浅拷贝还是深拷贝。

# 19/6-15

### drawable 的技巧

	获取手机屏幕的密度：

```java
  	float xdpi = getResources().getDisplayMetrics().xdpi;
    float ydpi = getResources().getDisplayMetrics().ydpi;
    Log.e(TAG, "onCreate: "+xdpi+"-----"+ydpi );
```

	我的手机结果如下：

```java
2019-06-14 13:10:55.635 3935-3935/com.admin.util E/MainActivity: onCreate: 560.0-----560.0
```

	那么 560 代表什么意思呢？如下表格所示：

|     dpi范围     |  密度   |
| :-------------: | :-----: |
|  0dpi ~ 120dpi  |  ldpi   |
| 120dpi ~ 160dpi |  mdpi   |
| 160dpi ~ 240dpi |  hdpi   |
| 240dpi ~ 320dpi |  xhdpi  |
| 320dpi ~ 480dpi | xxhdpi  |
| 480dpi ~ 640dpi | xxxhdpi |

	从表格可以 看出 560 是在 480-640 之间的，所以数据 xxxhdpi 的范围
	
	所以需要将图片放在 drawable-xxxhdpi 文件夹下。 然后使用 ImageView 去加载图片， 看一下效果，然后 放在 xhdpi 下在看一下效果。

如果将图片 放在 drawable- xhdpi 下，你会发现 图片会自动放大，这是为什么呢，下面就解释一下：

	当我用使用资源 id 去引用一张图片时，android 会使用一些规则去匹配最合适的图片。最合适的图片就是 比如手机密度是 xxxhdpi ,那么 drawable- xxxhdpi 文件下的图片就是最合适的图片，因此当加载图片是  drawable-xxxhdpi 文件夹下的图片就会被优先加载，在这种情况下图片是不会缩放的，但是如果 合适的文件夹下没有这个图片时，就会优先去更高密度的文件夹下加载图片， 我们当前使用的是 drawable-xxxhdpi ，如果没有需要的图片，就会去找更高密度的文件夹，如果没有，就会去更低密度的文件夹下找，依次是 drawable-xxhdpi -> drawable-xhdpi  -> drawable-hdpi  ->  drawable-mdpi -> drawable-ldpi 	
	
	匹配规则就是这样，必须现在在 drawable- xhdpi 下找到了这张图片，系统会认为 这个图片是 专门为低密度的设备设计的，如果将这个图片显示在过密度的设备上，就会出现像素过低的情况，于是系统帮我们做了一个放大的操作。
	
	还有一个文件夹是 drawable-nodpi文件夹  ，这个文件夹和 密度无关，放在这里的图片系统不会对他进行缩放，实际是多大就会显示多大。但是注意一下加载顺序，drawable-nodpi文件夹是在匹配密度文件夹和更高密度文件夹都找不到的情况下才会去这里查找图片的，因此放在drawable-nodpi文件夹里的图片通常情况下不建议再放到别的文件夹里面。 
	
	那么 缩放的 比例是多少呢，我测试了一下，将图片 设置在 xxx的文件夹后 宽度是 236 ,高为 420，放在 xx 的文件夹下 宽是 473,高是840，放在hdpi 下是 630,1120，放在 mdpi 下是 945,1680。从这个结果可以看出 他的缩放比例就是    2倍，3倍，4倍。当然这个 倍数不是 准确的，但是大概差不多。感兴趣的 可以尝试一下。

下面看一下内存：

当图片放在 mdpi 下内存为 30.8M 左右

![1560493649168](assets\1560493649168.png)

如果放在 xhdpi 下，内存为 26M左右

![1560493777823](assets\1560493777823.png)

经过上面的分析，答案也就出来了，一般情况下，图片尽量放在 高密度文件下，这样可以节省图片带来的内存开支，而UI在设计图片是 也应该 面向高密度屏幕的设备来设计，一般情况下 放在 xxhdpi 下是比较合适的。

### 获取 app 最大可用内存

```java
int max = (int) (Runtime.getRuntime().maxMemory()/(1024*1024));
Log.e(TAG, "onCreate: "+max+"M");
```

另外在Manifest application 里面添加 

```java
android:allowBackup="true"   
```

可以增加最大可用内存。

### 高效加载大图片

一般 我们在展示高分辨率的图片时，最好将图片进行压缩，压缩后的图片大小应该和 展示他的控件的大小相近，在一个很小的 ImageView 上显示一个大图片不会带来任何好处，但是会占用 相当多的内存，而且性能上也有可能会带来负面影响，

	BitmapFactory这个类提供了多个解析方法(decodeByteArray, decodeFile, decodeResource等)用于创建Bitmap对象，我们应该根据图片的来源选择合适的方法。比如SD卡中的图片可以使用decodeFile方法，网络上的图片可以使用decodeStream方法，资源文件中的图片可以使用decodeResource方法。这些方法会尝试为已经构建的bitmap分配内存，这时就会很容易导致OOM出现。为此每一种解析方法都提供了一个可选的BitmapFactory.Options参数，将这个参数的inJustDecodeBounds属性设置为true就可以让解析方法禁止为bitmap分配内存，返回值也不再是一个Bitmap对象，而是null。虽然Bitmap是null了，但是BitmapFactory.Options的outWidth、outHeight和outMimeType属性都会被赋值。这个技巧让我们可以在加载图片之前就获取到图片的长宽值和MIME类型，从而根据情况对图片进行压缩。如下代码所示： 

 	那我们怎样才能对图片进行压缩呢？通过设置BitmapFactory.Options中inSampleSize的值就可以实现。比如我们有一张2048*1536像素的图片，将inSampleSize的值设置为4，就可以把这张图片压缩成512*384像素。 

	如下所示：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    final ImageView imageView = findViewById(R.id.man_image);
    findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            //将图片压缩成100*100的缩略图，并在 ImageView 上显示
            imageView.setImageBitmap(decodeSampledBitmapFromResource(
                    getResources(),R.drawable.log,100,100));
        }
    });
}
public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,
                                                     int reqWidth, int reqHeight) {
    // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小
    final BitmapFactory.Options options = new BitmapFactory.Options();
    //禁止解析方法 为bitmap 分为内存
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeResource(res, resId, options);
    // 调用上面定义的方法计算inSampleSize值
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
    // 使用获取到的inSampleSize值再次解析图片
    options.inJustDecodeBounds = false;
    return BitmapFactory.decodeResource(res, resId, options);
}

public static int calculateInSampleSize(BitmapFactory.Options options,
                                        int reqWidth, int reqHeight) {
    // 源图片的高度和宽度
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;
    if (height > reqHeight || width > reqWidth) {
        // 计算出实际宽高和目标宽高的比率
        final int heightRatio = Math.round((float) height / (float) reqHeight);
        final int widthRatio = Math.round((float) width / (float) reqWidth);
        // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高
        // 一定都会大于等于目标的宽和高。
        inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;
    }
    return inSampleSize;
}
```
# 19/6-16

### 解决 9.0 没有网的问题

	在 res 下新增一个 xml 目录，然后创建一个名为：network_security_config.xml 文件（名字自定） ，内容如下，大概意思就是允许开启http请求

```java
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="true" />
</network-security-config>
```

	然后在APP的AndroidManifest.xml文件下的application标签增加以下属性 

```java
<application
...
 android:networkSecurityConfig="@xml/network_security_config"
...
/>
```

### 判断 SD卡是否存在

```java
 private File getCacheDir(Context context, String uniqueName) {
        String cachePath;
        // 判断 SD 卡是否可用
        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
                || !Environment.isExternalStorageRemovable()) {
            //获取 有sd 卡时的路径
            cachePath = context.getExternalCacheDir().getPath();
        } else {
            // 获取 无sd 卡时的路径
            cachePath = context.getCacheDir().getPath();
        }
        //File.separator 分隔符 /
        return new File(cachePath + File.separator + uniqueName);
    }
```

	getExternalCacheDir()方法来获取缓存路径  为  /sdcard/Android/data/<application package>/cache 
	
	getCacheDir() 方法获取的路径为 /data/data/<application package>/cache 

### AsynTask 并发执行

```java
//并行
task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,url);
```

### 使用线程池

```java
private static final ThreadFactory FACTORY = new ThreadFactory(){
    	//自增，保证原子性
        private final AtomicInteger mCount = new AtomicInteger();
        @Override
        public Thread newThread(Runnable r){
            return new Thread(r,"text ----＃"+ mCount.getAndIncrement());
        }
    };
    public static void main(String [] args){
        ThreadPoolExecutor textPool = new ThreadPoolExecutor(3,5,0L 
,TimeUnit.MILLISECONDS, new LinkedBlockingDeque<Runnable>(),FACTORY);
        for(int i = 0; i <10; i ++){
            textPool.execute(new Runnable(){
                @Override
                public void run(){
                    System.out.println(Thread.currentThread().getName());
                }
            } );
        }
    }
```

# 19/6-18

### 谈谈如何重写 equals 方法，为什么还要重写 hashCode ？

equals：比较两个对象的地址是否相等

hashCode ：一般用在集合里面，比如在hashMap 里面，存入元素的时候 会首先算出 哈希值，然后根据哈希值来确定元素的位置，对于在任何一个对象上调用hashCode 时，返回的 哈希值一定相等的。

为什么 需要重写 hashCode

	给集合中存元素时，首先会获取 hashCode 的值，如果没有重写 hashCode ，他会直接将元素的地址转换成一个整数返回。如果我们创建了两个对象，两个对象的所有属性值都一样，在存入HashSet 时，第一个元素会直接存进去，第二个获取的 哈希值 和 第一个不同，所以第二个元素也会存进去，因为 jdk 默认不同的 hashCode 值，equals 一定返回false。所以 这两个值都会被存进去。但是这两个对象的属性值都是一样的，所以这样会造成数据的不唯一性。所以一般重写了 equals 后必须要重写 hashCode。

内存泄露的问题

	想象一下，一个类 创建了两个对象，属性值不同，同时重写了 equals 和 hashCode 。然后将他们都存进了 HashSet 中。然后修改第二个 元素的值。最后将第二个元素充 set 集合中删除。 删除之后 则迭代进行打印，会发现第二个元素没有被删除掉，为什么呢？ 因为在删除 某个元素时，会获取 hashCode 值，但是由于修改了属性值，导致获取的 哈希值和 存入时获取的不同，所以查找为空，jdk 认为该对象不在集合中，所以不会进行删除操作，但是用户认为 对象已经被删除，导致该对象长时间不能被释放，造成内存泄露。解决的办法是不要在执行的期间 修改与 HashCode 值相关的对象信息，如果非要修改，则必须先从集合中删除，更新数据后在添加到集合。 

总结：

	1.hashCode是为了提高在散列结构存储中查找的效率，在线性表中没有作用 
	
	2.equals和hashCode需要同时覆盖。 
	
	3.若两个对象equals返回true，则hashCode一定返回相同的int数。 
	
	4.若两个对象equals返回false，则hashCode不一定返回不同的int数,但为不相等的对象生成不同hashCode值可以提高 哈希表的性能 
	
	5.若两个对象hashCode返回相同int数，则equals不一定返回true。 
	
	6.若两个对象hashCode返回不同int数，则equals一定返回false。 
	
	7.同一对象在执行期间若已经存储在集合中，则不能修改影响hashCode值的相关信息，否则会导致内存泄露问题。 

### android DiskCacheDir 硬盘缓存

	<https://blog.csdn.net/baidu_40389775/article/details/92840804> 

### DiskCacheDir的封装

	<https://blog.csdn.net/baidu_40389775/article/details/92847114> 

### DiskCacheDir + LruCache + AsynTask 的封装 

### 	https://blog.csdn.net/baidu_40389775/article/details/92847157 

# 19/6-19

### 说一说 https ，udp，socket 的区别

	https：https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 
	
	socket ： 俗称 套接字，它是一种连接模式，不是协议，socket 是对 TCP/IP 的封装。socket 建立的是长连接，保持客户端与服务端。
	
	udp：是非面向连接的协议，发送数据时不管对方是否在线，无需建立连接，如微信发送一个消息，对方在不在线无所谓。

### 简要说说LruCache 的原理

	LruCache 非常适合用于 缓存图片，他的主要算法原理是包最近使用的对象 存储在 LinckHashMap中，并且把最近使用的最少的对象在 缓存值达到预设值之前从内存中移除
	
	简单的封装如下

```java
public class LruCachePhoto {
    /**
     * 图片 缓存技术的核心类，用于缓存下载好的所有图片，
     * 在程序内存达到设定值后会将最少最近使用的图片移除掉
     */
    private LruCache<String, Bitmap> mMenoryCache;

    public LruCachePhoto() {
        //获取应用最大可用内存
        int maxMemory = (int) Runtime.getRuntime().maxMemory();
        //设置 缓存文件大小为 程序最大可用内存的 1/8
        int cacheSize = maxMemory / 8;

        mMenoryCache = new LruCache<String, Bitmap>(cacheSize) {
            @Override
            protected int sizeOf(String key, Bitmap value) {
                return value.getByteCount();
            }
        };
    }

    /**
     * 从 LruCache 中获取一张图片，如果不存在 就返回 null
     *
     * @param key LurCache 的键，这里是 图片的地址
     * @return 返回对应的 Bitmap对象，找不到则为 null
     */
    public Bitmap getBitmapFromMemoryCache(String key) {
        return mMenoryCache.get(key);
    }

    /**
     * 添加一张图片
     *
     * @param key    key
     * @param bitmap bitmap
     */
    public void addBitmapToCache(String key, Bitmap bitmap) {
        if (getBitmapFromMemoryCache(key) == null) {
            mMenoryCache.put(key, bitmap);
        }
    }
}
```


# 19/6-21

###  Failed to transform artifact 'butterknife-runtime.aar (com.jakewharton:butterknife-runtime:10.1.0)'

报错信息如下：

Execution failed for task ':app:mergeExtDexDebug'.

> Could not resolve all files for configuration ':app:debugRuntimeClasspath'.
>  > Failed to transform artifact 'butterknife-runtime.aar (com.jakewharton:butterknife-runtime:10.1.0)' to match attributes {artifactType=android-dex, dexing-is-debuggable=true, dexing-min-sdk=15}
>  >   > Execution failed for DexingTransform: C:\Users\Lv_345\.gradle\caches\transforms-2\files-2.1\8e0adaeeb74965e53b877012710dd195\jars\classes.jar.
>  >   >
>  >   >    > Error while dexing.

解决：给所有的 Module 加入jdk1.8

在 build.gradle 的 android 下加入下面代码 即可解决

```java
compileOptions {
    sourceCompatibility = '1.8'
    targetCompatibility = '1.8'
}
```
# 19/6-24

### PHP 连接数据库

```php
$like = mysqli_connect("192.168.167.2","345","111111","frame");
if (!$like){
    echo "连接数据库失败";
}
```

### PHP 获取 get 请求数据

```php
//获取get 请求的数据
if ($_GET) {
    if (isset($_GET['name'], $_GET['age'])) {
        echo $_GET['name'] . "----" . $_GET['age'];
    }
}
```

### PHP 获取 post 请求的 json 数据、

```php
//获取 post 请求的json数据
if (empty($_POST)) {
    //获取json数据
    $data = file_get_contents('php://input');
    //将json 解析为数组
    $Content = json_decode($data,true);
    $abc =$Content['name'];
    echo $abc;
}
```

### PHP 返回一个 json 数据

```java
$result["result"] = "ok";
$result["data"] = $array;
//将数组 转为 json 串
$result = json_encode($result, JSON_UNESCAPED_UNICODE);
echo $result;
```

### PHP 执行 sql 查询 语句

```php
$like->set_charset("utf8");
$sql = "SELECT * FROM `account`  ";

$mysqli_result = $like->query($sql);

if (!$mysqli_result) {
    $res['code'] = 200;
    $res['result'] = "error";
    echo json_encode($res,JSON_UNESCAPED_UNICODE);
}else{
    while ($temp =  $mysqli_result->fetch_assoc()){
        if ($email == $temp['email']){
            if ($password == $temp['password']){
                $res['code'] = 200;
                $res['result'] = "success";
                echo json_encode($res,JSON_UNESCAPED_UNICODE);
            }
        }
    }
}
```
# 19/6-25 ——26

### Callable 与 Runnable

先看一下Runnable ，他是一个接口，提供了一个 run方法

```
public interface Runnable {
    public abstract void run();
}
```

由于他的返回值是 run，所以在执行完任务后没有任何返回结果

下面看一下 Callable ，他也是一个接口，有一个方法，名字为 call() ;

```java
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
```

这是一个泛型接口，并且带有返回值，返回值也是一个 泛型。

### Future

Future 就是对具体的Runnable 或者 Callable 任务执行结果进行取消，查询是否完成·，后去结果，必要时可以通过get 方法获取执行结果，该方法会左侧知道任务返回结果

Future 是一个接口

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

- cancel 方法用来 取消任务，成功返回 true，失败返回 false。 参数表示允许取消正在执行却没有执行完毕的任务，如果设置为 true，则表示可以取消在执行过程中的任务，**如任务已完成，则无论参数为 true 或者 false，此方法肯定返回false**，即如果取消已经完成的任务会返回false；**如果任务正在执行，若参数为 true ，则返回 true，若 参数为 false，如任务没有执行，则不论参数为 true 或者false，肯定返回true**；
- isCancelled 表示任务是否被成功取消，如果任务在正常完成前被取消成功，则返回true。
- isDone 方法表示任务是否已经完成，若任务已经完成，返回true。
- get 获取任务执行的结果，该方法会产生阻塞，指定任务执行完毕 才返回。
- get(long timeout ,TimeUnit unit) 获取执行结果，还没获取到结果就直接返回 null

也就是说 Future 提供了三种功能：

1，判断任务是否完成

2，中断任务

3，能够获取任务的执行结果

因为 Future 是一个接口，没办法用来创建对象使用，所有就有了下面的 FutureTask

FutureTask

### FutureTask 的实现

```java
public class FutureTask<V> implements RunnableFuture<V> {
}
```

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```

可以看出 FutureTask 实现了 Runnable 和 Future 接口，所以他既可以作为Runnable 被线程执行，又可以作为Future 得到 Callable 的返回值

FutureTask 提供了两个构造器

```java
public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}
public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
```

FutureTask 是Future 接口的唯一实现类



### 使用示例

#### Callable+Future 获取执行结果

```java
//使用 Callable + Future 获取执行结果
Callable<Integer> callable = () -> {
    int sum = 0;
    for (int i = 0; i < 100; i++) {
        sum += i;
    }
    return sum;
};
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<Integer> result = executor.submit(callable);

executor.shutdown();
try {
    System.out.println("线程返回结果"+result.get());
} catch (Exception e) {
    e.printStackTrace();
}
```

#### Callable + FutureTask 获取执行结果

```java
 //使用 Callable + FutureTask 获取执行结果
 Callable<Integer> callable = () -> {
     int sum = 0;
     for (int i = 0; i < 100; i++) {
         sum += i;
     }
     return sum;
 };
 //第一种方式
 FutureTask<Integer> futureTask = new FutureTask<>(callable);
 ExecutorService executor = Executors.newSingleThreadExecutor();
 executor.submit(futureTask);
 executor.shutdown();//执行任务

/* //第二种方式 ，和第一种差不多，只不过一个是线程池，一个是 Thread
 FutureTask<Integer> future = new FutureTask<>(callable);
 Thread thread = new Thread(future);
 thread.start();*/
 try {
     System.out.println(futureTask.get());
 } catch (Exception e) {
     e.printStackTrace();
 }
```

### 使用 FutureTask 的好处

FutureTask 是为了 弥补 Thread 的不足而设计的，他可以让程序员准确的知道线程什么时候执行完，并获得线程执行案后返回的结果，Future 可以取消异步任务，他的计算是通过 Callable 来实现的。他等价可以携带的结果的Tunnable ，并且有三个状态，等待 ，运行，和完成。完成包括所以计算已任意方式结束，正常结束，取消和 异常。

### android 中更多的线程

除了上面这些，在android中充当线程的角色 还有 AsyncTask，HandlerThread，IntentService。他们本质上都是由HandlerThread 来构成的，

#### AsyncTask

	他封装了 线程池 和 Handler ，主要为我们在子线程中更新 UI 提供便利
	
	它是一个抽象的泛型类，声明：

```java
public abstract class AsyncTask<Params, Progress, Result> {......
```

- 参数1，Params，异步任务的入参；

- 参数2，Progress，执行任务的进度；

- 参数3，Result，后台任务执行的结果；

- 方法1， onPreExecute()，在主线程中执行，任务开启前的准备工作；

- 方法2，doInbackground(Params…params)，开启子线程执行后台任务；

- 方法3，onProgressUpdate(Progress values)，在主线程中执行，更新UI进度；

- 方法4，onPostExecute(Result result)，在主线程中执行，异步任务执行完成后执行，它的参数是doInbackground()的返回值。

  从上面可以清楚的看到AsynTask的具体用法。
  
  [AsyncTask源码分析](https://blog.csdn.net/baidu_40389775/article/details/93745776)

#### HandlerThread

	HandlerThread 继承了 Thread，也实现了run方法，我们先看一下使用方式：

```java
  		HandlerThread thread = new HandlerThread("HandlerThread");
        thread.start();

        mHandler = new Handler(thread.getLooper()){
            @Override
            public void handleMessage(Message msg) {   
                    Log.e("------", "handleMessage: "+msg.obj );
            }
        };

        new Thread(() -> {
            String str = "子线程发送数据";
            Message obtain = Message.obtain();
            obtain.obj = str;
            mHandler.sendMessage(obtain);
        }).start();

        String str = "主线程发送数据";
        Message obtain = Message.obtain();
        obtain.obj = str;
        mHandler.sendMessage(obtain);

	   //当名确不在使用 HandlerThread，则需要终止线程的运行
        thread.quit();
```

首先创建 HandlerThread 的实例，接着创建Handler，最后分别在主线程和 子线程发送消息。



下面看一下分析一下 ThreadThread。

首先看 他的run 方法

```java

    @Override
    public void run() {
        mTid = Process.myTid();
        Looper.prepare();
        synchronized (this) {
            mLooper = Looper.myLooper();
            notifyAll();
        }
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        Looper.loop();
        mTid = -1;
    }
```

在run方法中(run方法里面的逻辑是在子线程执行的)，创建了一个子线程的looper，然后将 looper 给 mLooper。最后调用loop 方法，不断的从 MessageQueue 中取出消息，没有消息就阻塞，有消息就会唤醒。

我们在创建 Handler 的时候是这样创建的，这样 我们的mHandler 和 Looper 就在一个线程中了。

```java
     mHandler = new Handler(thread.getLooper()){......}
```

getLooper 的源码：

```java
 public Looper getLooper() {
        if (!isAlive()) {
            return null;
        }    
        // If the thread has been started, wait until the looper has been created.
        synchronized (this) {
            while (isAlive() && mLooper == null) {
                try {
                    wait();
                } catch (InterruptedException e) {
                }
            }
        }
        return mLooper;
    }
```

他的返回值就是 在run 方法中创建的 mLooper，所以 getLooper 必须在 start 之后调用，

当 mHandler 发送消息后，会把这个消息添加进 队列。然后Looper.loop就会取出消息，交给Handler 进行分发。到这里分析完了。

但是还有一点需要说一下，在 run 方法中 mLooper 创建完后 有notifyAll ，getLooper() 中有 wait ，这是为什么呢？ 因为在创建 Handler 对象时 需要用到 mLooper ，但是如果 run方法 还么有创建 mLooper ，就会获取不到 mLooper。所以在这里进行 wait()，也就是说 我们必须等到 mLooper 的创建完成。

总结一下：

	HandlerThread 就相当于在子线程创建了 一个 消息循环。说白了就是分担 主线程的工作量，降低了主线程的压力，HandlerThread 处理 任务是 串行执行，按照发送的顺序进行处理，HandlerThread 本质是一个县城，在线程内部，代码是串行执行的，如果一个 任务执行的实现过程，那么就导致后续的任务都被延迟处理。HandlerThread 有自己的队列，不会打扰 到 主线程。

#### IntentService

	IntentService 是一个 继承Service 的抽象类，因此必须创建他的子类 才可以使用IntentService ，IntentService 用来执行后台耗时的任务，当任务执行后他会自动停止，同时由于IntentService 是服务的原因，他比较适合执行以下优先级高的任务，IntentService封装了 Handler 和 Thread  ，和 HandlerThread 非常相似。

下面分析一下源码：

```java
	private volatile Looper mServiceLooper;
    private volatile ServiceHandler mServiceHandler;	

	private final class ServiceHandler extends Handler {
        public ServiceHandler(Looper looper) {
            super(looper);
        }

        @Override
        public void handleMessage(Message msg) {
            onHandleIntent((Intent)msg.obj);
            stopSelf(msg.arg1);
        }
    }	

    @Override
    public void onCreate() {
        // TODO: It would be nice to have an option to hold a partial wakelock
        // during processing, and to have a static startService(Context, Intent)
        // method that would launch the service & hand off a wakelock.

        super.onCreate();
        HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");
        thread.start();

        mServiceLooper = thread.getLooper();
        mServiceHandler = new ServiceHandler(mServiceLooper);
    }
```

当 IntentService 被第一次启动时，onCreate 会被调用，onCreate 会创创建一个 HandlerService，然后 通过他的 Looper 创建一个 ServiceHandler 对象。这样只要使用的是 mServiceHandler 发送的消息 都会在 HandlerThread 中执行，最后在分发到 ServiceHandler 的 handleMessage。

我们重复启动某个服务时，不会开启新的服务，只是会调用 onStartCommand 方法。onStartCommand 就会去调用 onStart() 方法。如下所示：

```java
	public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
        onStart(intent, startId);
        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;
    }
    
     @Override
    public void onStart(@Nullable Intent intent, int startId) {
        Message msg = mServiceHandler.obtainMessage();
        msg.arg1 = startId;
        msg.obj = intent;
        mServiceHandler.sendMessage(msg);
    }	
```

在onStart 中，使用mServiceHandler 发送了一个消息，这个消息在 HandlerThread 里面被处理，然后被 mServcieHandler 接收，接着就会调用 onHandleInteger 处理消息。

处理完消息后就会 调用 stopSelf(msg.arg1) 来尝试停止任务，这里之所以采用 stopSefl( int startId ),而不是使用 stopSelf 是因为 stopSelf 会立刻停止服务，但是这个时候可能有其他 消息没有处理。stopSelf(int startId ) 则会等待所有的消息处理完毕后才终止 服务，

当我们有多个后台任务时，就需要执行多次 启动 IntentService 。Handler 中的 Looper 是顺序处理消息的，所以IntentService 也是 顺序处理消息的，有多个任务需要执行时，这些任务会按照 发起的顺序排序执行。

使用如下：

```java
public class MyIntentService extends IntentService {


    public MyIntentService() {
        super("MyIntentService");
    }

    @Override
    protected void onHandleIntent(@Nullable Intent intent) {
        String action = intent.getStringExtra("service");
        Log.e("---------", "onHandleIntent: "+action );
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.e("---------", "onDestroy: 服务销毁" );
    }
}
```

```java
        Intent intent = new Intent(this,MyIntentService.class);
        intent.putExtra("service","消息1");
        startService(intent);
        Intent intent1 = new Intent(this,MyIntentService.class);
        intent1.putExtra("service","消息2");
        startService(intent1);
        Intent intent2 = new Intent(this,MyIntentService.class);
        intent2.putExtra("service", "消息3");
        startService(intent2);
```

# 19/6-27

### 谈谈ThreadLocal 的用法和 原理：

	ThreadLocal 用来保存数据，且每个线程之间互不影响，比如 在主线程保存了一个 对象，但是在子线程中 就无法找到这个对象。
	
	ThreadLocal 是一个线程内部的数据存储类，通过他可以指定线程中存储的数据，在读取时，只有指定的线程才可以读取到数据，其他线程无法拿到数据。
	
	ThreadLocal 在保存数据时 会获取当前操作的线程，然后将数据保存在当前线程的 ThreadLocalMap 中，以当前的对象为键，数据为值，进行保存。
	
	ThreadLoca 在获取数据时，和保存非常相似，都是拿到当前的线程对象，然后去判断 线程对象的 ThreadLocalMap 是否为空，如果为空，则 没有数据，否则 则获取数据。
	
	 从ThreadLocal的set 和 get 方法可以看出，他们操作的都是根据当前线程中的ThreadLocal.ThreadLocalMap threadLocals = null 来判断当前线程有没有保存数据，如果保存了，就会在当前线程中产生一个ThreadLocalMap 的对象 。数据就会保存在这个对象 里面，如果 没有保存过数据，那么当前线程中的ThreadLocalMap 就会为空。他们对ThreadLocal 所做的读/写操作仅限于线程的内部。因此在不同线程中访问同一个ThreadLocal的 set 和 get 方法 所得到的值 也是不一样的。

### JVM ,Dalvik ，ART , 三者的原理和区别

- JVM : 是java 虚拟机的缩写，其并不是指某个特定的虚拟机实现，而是指能够运行 java 字节码(类文件) 的虚拟机实现，
- Dalvik ： 是谷歌写的一个用于 android 的虚拟机，但严格来说并不算 JVM（没有遵循 java 虚拟机的规范，比如字节码格式是 DEX ，而非 .class）
- ART : 是 Android Runntime 的缩写，严格来时并不是一个虚拟机，ART在安卓4.4时加入，5.0取代的Dalvik作为唯一实现直到现在。

### java 中的 wait ，notify，notifyAll 

	wait：线程自动释放其占有的锁，导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法。
	
	notify ：唤醒正在等待对象监视器的单个线程。
	
	notifyAll ：唤醒正在等待对象监视器的所有线程。

### CountDownLatch 

 	CountDownLatch 的作用是 倒数，每当一个线程执行完任务后，他就会减一，直到为 0 时 就代表所有的线程的任务都执行完了。总得来说 CountDownLatch 就是等待其他线程执行完任务。

	详见 android/Thread/CountDownLatch 控制多线程并发等待

### android 中访问资源的方式

- 引用自定义资源。格式 @[package:]type/name

  android:text="@string/hello wold"

- 引用系统资源，格式 @android:type/name

  android:textColor:"@android:color/opaque_red"

- @* 代表引用系统的非public 资源，格式 @*android:type/name

  系统资源定义分 public 和 非public，public 的声明在

   <sdk_path>\platforms\android-8\data\res\values\public.xml

   **@\*android:type/name：**可以调用系统定义的所有资源

   **@android:type/name：**只能够调用public属性的资源。

  注意：没有在 public.xml 中声明的资源是 google不推荐使用的

- ？代表引用主题属性

  		另外一种资源值 允许你引用当前主题中的属性的值。这属性值能能在style资源 和 XML 属性中使用，它允许你通过他们改变为 当前主题提供标准变化来改变 UI 元素的外观。例如：

  android:textColor="?android:textDisabledColor" 

- @+ 表示在创建或者引用资源，格式 @+ type/name

   @+id/资源ID名         新建一个资源ID

   @id/资源ID名          应用现有已定义的资源ID，包括系统ID

   @android:id/资源ID名   引用系统ID，其等效于@id/资源ID名

   android:id="@+id/selectdlg"

   android:id="@android:id/text1"

   android:id="@id/button3"  

参考自：https://blog.csdn.net/mingli198611/article/details/7105850

### android 根据资源名字获取资源 id 

	首先看一个布局

```java
  <Button
        android:id="@+id/index_btn"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
```



然后通过一个字符串 找到这个id

```
 	    int index_btn = res.getIdentifier("index_btn", "id", getProxyActivity().getPackageName());
        Button button = rootView.findViewById(index_btn);
        button.setOnClickListener((view)->{
            Toast.makeText(getContext(), "哈哈哈", Toast.LENGTH_SHORT).show();
        });
```

第一个参数为 名字，第二个就是 类型，第三个 则是包名