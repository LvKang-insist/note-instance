## 算法的效率

算法的效率主要由以下两个复杂度来评估：

#### 时间复杂度：评估执行程序所需要的时间。可以估算出程序对处理器的使用程度

#### 空间复杂度：评估执行程序所需要的的存储空间。可以估算出程序对计算机内存的使用程度

设计算法时，一般要**先考虑系统环境，然后在权衡时间复杂度和空间复杂度，选取一个平衡点**。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法主要研究的也是时间复杂度，不说明的情况下，复杂度指的就是时间复杂度。

---

下面看一个小栗子：

```kotlin
fun fun1(): Int {
    println("哈，我是345")
    return 0;
}


fun fun2(n: Int): Int {
    for (i in 0..n) {
        println("哈，我是345  ")
    }

    return 0
}
```

首先，调用一次 fun1，内部会执行两次语句，这个两次可以记做为常数

调用一次 fun 2，内部会执行  1 + (n+1)+n +n +1，也就是 3n +3次，为啥呢，如下：

**1，首先 i = 1是一次**。

**2，i 每次循环会自增，则执行 n 次**。

**3，i 每次会判断是否小于 n ，会执行 n+1 次**。

**4，打印语句会执行 n 次**

**5，return 一次**

**最终的结果为 3n+3次**

---

一段代码的执行次数会用 T(n) 表示

T(n)：其中 n 是输入数据的大小，或者是输入数据的数量，T 则是，当输入的数量为 n 的时候，这段代码执行的总次数。

但是作为衡量代码的执行速度的依据，使用 T(n) 就有点麻烦了，我们还要一条一条语句去数，而且函数调用函数的时候，运算起来也很麻烦，所以算法一般使用 T(n) 简化的估算值，来衡量代码的执行速度。这个简化的估算值叫做时间的复杂度

### T(n) 如何得出一个时间复杂度

- 如果 T(n) = 常数

  那么时间复杂度可以估算为 1 ，因此 T(n) = 2 的**复杂度就是 1**

  对于 fun1() 函数，他的执行次数是一个常数，也就是说他的数量是固定的，那么他的时间复杂度就是 1.

- 如果 T(n) = **常数 * n** + 常数

  可以直接 去掉后面的 + 常数，应为当 (常数 * n) 越来越大，后面的则是保持不变，所以后面的相当于不存在，所以可以直接省略

  然后 (常数 * n) 中的常数可以估算为 1，也可以理解为去掉这个作为系数的常数，所以他的时间复杂度就是 n

  对于 fun2() 函数，他的执行次数是 常数 *n ，那么他的时间复杂度就是 n

  **因此 T(n) = 3n + 3 的复杂度为 n**

- T(n) = 5n³ + 6666n² + 233

  对于多项式，我们只需要保留 n 的最高次项，也就是保留 n 的次方数最大的那一项

  因此 时间复杂度就是 n³

上面表示的时间复杂度并不完整，我们还需要加上大写字母 O ，如 O(1) ，O(n) ，O(n³)

总结一下，时间复杂度的表示方法**，如果 T(n) 是常数，时间复杂度为 1，如果不是，时间复杂度为 O(保留 T(n) 的最高次项并且去掉这个最高次项的系数)**

```kotlin
fun fun3(n: Int) {
    for (i in 0..n) {
        for (j in 0..n) {
            println("哈，我是345  ")
            println("哈，我是345  ")
        }
    }
}
```

对于 fun3，里层的复杂度为 n，外层的复杂度也是 n，然后在外层循环的作用下，里层循环执行了 n 次，即就是 n*n 次，所以复杂度为 n²，也就是 O(n²)。

由此就可以推断出，如果有 x 层循环，他的时间复杂度就是 O(n^x)

