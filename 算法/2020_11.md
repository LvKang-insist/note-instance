## 1，二分查找法

```kotlin
/**
 * 二分查找
 */
fun test(intArray: IntArray, searInt: Int): Int {
    var left = 0
    var right = intArray.size - 1
    while (left <= right) {
        val temp = (left + right) / 2
        when {
            searInt == intArray[temp] -> return temp
            searInt > intArray[temp] -> left = temp + 1
            searInt < intArray[temp] -> right = temp - 1
        }
    }
    return -1
}

fun main() {
    val array = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
    println(test(array, 9))
}
```

思路：取中间元素进行判断，如果大于，则取下一个和最后一个进行计算中间值，以此类推。如果小于，则取上一个和第一个进行计算，以此类推。

## 2，用两个栈实现一个队列

```kotlin
/**
 * 用两个栈实现队列
 */
val s1: Stack<Int> = Stack()
val s2: Stack<Int> = Stack()

fun appendTail(value: Int) {
    s1.push(value)
}

fun deleteHead(): Int {
    if (s2.empty()) {
        while (s1.isNotEmpty()) {
            s2.push(s1.pop())
        }
    }
    return if (s2.isNotEmpty()) s2.pop() else -1
}

fun main() {
    appendTail(1)
    appendTail(2)

    println(deleteHead())
    println(deleteHead())
    println(deleteHead())
}
```

栈：先进后出

队列：先进先出

思路：在出栈的时候将 s1 中的元素 pop 到 s2 中，然后从 s2 中 pop 即可

## 3，两数之和

给定一个数组，一个 target，求数组中某两个元素之和等于 target，数组只能遍历一遍

```kotlin
/**
 * 两数之和
 */
fun twoSum(nums: IntArray, target: Int): IntArray {

    val map = mutableMapOf<Int, Int>()

    for (i in nums.indices) {
        if (map.containsKey(target - nums[i])) {
            return intArrayOf(map[target - nums[i]]!!, i)
        }
        map[nums[i]] = i
    }

    return intArrayOf()
}

fun main() {
    val intArrayOf = intArrayOf(0, 1, 4, 5, 8, 16, 34, 9)

    println(twoSum(intArrayOf, 10).joinToString())
}
```

思路：使用hash表，将元素作为 key 存入 hashMap 中，元素的下标为 value。若 target - 数组[i] 等于 map 中的 key，则说明已找到，从 map 中获取下标即可。