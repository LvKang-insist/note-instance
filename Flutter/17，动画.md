### 简介

在任何系统的 UI 框架中，动画的实现原理都是相同的，即：在一段时间内，快速地多次改变 UI 外观；由于人眼会产生视觉停留，所以最终看到的就是一个连续的动画；

我们将 UI 的一次改变称为一个动画帧，对应一次屏幕的刷新，而决定动画流畅度的一种重要指标就是 FPS，即每秒的动画帧数。帧数越高，动画就会越流畅；

一般情况下，动画帧率超过 16FPS ，就比较流畅了，超过 32FPS 就会非常细腻平滑，而超过32FPS 人眼基本就感受不到差别了，由于动画每一帧都是要改变 UI 输出，对设备的软硬件要求都较高，所以在 UI 系统中，动画的平均帧数是重要的指标，而在 Flutter 中，理想状态下是可以实现 60FPS 的，这和原生应用基本是持平的



### Flutter 中动画抽象

为了方便开发者创建动画，不同的 UI 系统对动画都进行了抽象，如 Android 中可以通过 xml 来描述一个动画并设置给 View，Flutter 中也对动画进行了抽象，主要涉及 Animation，Curve，Controller，Tween 这四个角色，他们一起配合完成一个完整的动画。

#### Animation

`Animation` 是一个抽象类，它本身和 UI 渲染没有任何关系，它主要的功能是保存动画的插值和状态，其中比较常用的是 Animation<double> 。Animation 对象是一个在一段时间内依次生成一个区间(Tween) 之间的值。

Animation 对象在动画执行的过程中输出可以使线性的，曲线的，一个步进函数或者曲线函数等，这由 `Curve` 来决定。根据 Animation 对象的控制方式，动画可以正向，反向运行，也可以在中间切换方向。Animation 还可以生成 Animation<Color>，或者 Animation<Size> 等，在动画的每一帧中，我们可以通过 Animation 对象的 value 属性获取动画的当前值。

**动画感知**

我们可以通过 Animation 来监听动画的每一帧以及执行状态的变化，nimation 有如下两种写法：

1，addListener() ，给 Animation 添加帧监听器，在每一帧都会被调用。帧监听器中最常见的行为是改变状态后调用 setState 触发 UI 重建

2，addStateListener，添加动画状态改变监听器，可以监听动画开始，结束，正向，方向等，触发是会调用改监听器



#### Curve

动画的过程可以使匀速，加速，先加后减等。Flutter 中通过 Curve(曲线) 来描述动画过程，我们把匀速动画称为(Curves.linear)，而非匀速动画称为非线性。

我们可以通过 CurvedAnimation 来指定动画的曲线，如：

```dart
final CurvedAnimation curve =
    new CurvedAnimation(parent: controller, curve: Curves.easeIn);
```

CurvedAnimation 可以通过包装 AnimationController 和 Curve 生成一个新的动画对象，我们正式通过这种方式来讲动画和动画执行的曲线关联起来的；

我们指定动画的曲线为 Curves.easeIn，表示由慢到快，[Curves](https://api.flutter.dev/flutter/animation/Curves-class.html) 类是一个预置的枚举类，定义了很多常用的曲线，如下：

| Curves曲线 | 动画过程                     |
| ---------- | ---------------------------- |
| linear     | 匀速                         |
| decelerate | 匀减速                       |
| ease       | 开始减速，后加速             |
| easeIn     | 由慢到快                     |
| easeOut    | 由快到慢                     |
| easeInOut  | 开始慢，然后加速，最后再减速 |

除了上面列举的，[Curves](https://api.flutter.dev/flutter/animation/Curves-class.html) 类中海油很多其他的曲线，并且附有动画执行过程，大家可自行查看

当然，我们也可以创建自己的 Curve，如定义一个正弦曲线：

```dart
class ShakeCurve extends Curve {
  @override
  double transform(double t) {
    return math.sin(t * math.PI * 2);
  }
}
```



#### AnimationController

`AnimationController` 用于控制动画，它包含 forward(启动)，stop(停止)，reverse(反向) 等方法，`AnimationController` 会在动画的每一帧生成一个新的值，默认情况下给定的默认区间是 0.0 到 1.0。例如下面代码创建一个 Animaction 对象：

```dart
final AnimationController controller = new AnimationController(duration: const Duration(milliseconds: 2000), vsync: this);
```

AnimationController 生成的数字区间可以用 lowerBound 和 upperBound 来指定，如：

```dart
final AnimationController controller = new AnimationController( 
 duration: const Duration(milliseconds: 2000), 
 lowerBound: 10.0,
 upperBound: 20.0,
 vsync: this
);
```

AnimationControler 派生子 Animation<double> ，因此可以在需要 Animation 对象的任何地方使用。但是它具有控制动画的其他方法，如启动正向动画，反向动画等。在动画执行后开始生成动画帧，屏幕每刷新一次就是一个动画帧；

在动画的每一帧，会随着动画曲线来生成当前的动画值(Animation.value) 。然后根据当前动画值去构建 UI ，当所有动画帧依次触发时，动画值就会改变，对应的 UI 就会发生变化，最终就可以看到完整的动画；

duration 表示动画执行的时长，通过它可以控制动画的速度。

>注意：在某些情况下，动画可能会超出 0.0 到 1 的返回，这取决于具体的曲线，例如，fing() 函数可以根据手势滑动(甩出) 的速度，力量来模拟一个手指甩出的动画，因此，他的动画值可以在 [0.0,1.0] 的范围之外。也就是说，根据选择的曲线，CurvedAnimation 的输出可以比输入有更大的范围。
>
>例如 Curves.elasticln 等弹性曲线会生成大于或小于默认范围的值

**Ticker**

当创建一个 AnimationController 时，需要传递一个 vsync 参数，它接收一个 TickerProvider 类型的对象，他的主要职责是创建 Ticker，定义如下:

```dart
abstract class TickerProvider {
  //通过一个回调创建一个Ticker
  Ticker createTicker(TickerCallback onTick);
}
```

Flutter 应用在启动时都会绑定一个 SchedulerBinding，通过 SchedulerBinding 可以给每一次屏幕刷新添加回调，而 Ticker 就是通过 SchedulerBinding 来添加屏幕刷新的回调，这样依赖，每次屏幕刷新都会调用 tIckerCallback，使用 Ticker 来驱动动画会防止屏幕外动画（动画的 UI 不在当前屏幕时，如锁屏时）消耗不必要的资源，因为 Flutter屏幕刷新时会通知到绑定的 SchedulerBinding，而 Ticker 是受 SchedulerBinding 驱动的，由于锁屏后屏幕就会停止刷新，所以 Ticker 就不会触发；

通常我们会将 `SingleTickerProviderStateMixin` 添加到 State 定义中，然后将 State 对象作为 vsync 的值，这在后面的例子中可以看到；



#### Tween

默认情况下，AnimationController 对象范围是 [0.0 ,1.0] 。如果我们需要构建的 UI 的动画值在不同的范围，或者是不同的数据类型，则可以使用 Tween 来添加映射以生成不同范围或数据类型的值。例如：生成 [-200.0, 0.0] 的值

```dart
final Tween doubleTween = new Tween<double>(begin: -200.0, end: 0.0);
```

Tween 构造函数需要 begin 和 end 两个数。Tween 的唯一职责就是定义从输入范围到输出范围的映射。通常输入范围是 [0.0,1.0] ，我们可以自定义这个范围

Tween 继承自 Animatable<T> ，而不是 Animation ，Animatable 中主要定义的是动画值的映射规则。

例如将动画输入范围映射为两种颜色值之间过度输出：

```dart
final Tween colorTween = new ColorTween(begin: Colors.transparent, end: Colors.black54);
```

Tween 对象不存储任何状态，想法，它提供了 evaluate 方法，可以获取动画当前映射值。Animation 对象的当前值可以通过 value 方法获取到。evaluate 函数还执行一些其他处理，例如分别确保在动画值为 0.0 和 1.0 是返回开始和结束状态。

**Tween.animate**

要使用 Tween 对象，需要调用其 `animate()` 方法，然后传入一个控制器对象，例如，在 500 毫秒内生成从 0 到 255 的整数值，

```dart
final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 500), vsync: this);
Animation<int> alpha = new IntTween(begin: 0, end: 255).animate(controller);
```

注意 animate 方法返回的是一个 Animation，而不是 Animatable。

```dart
final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 500), vsync: this);
final Animation curve = new CurvedAnimation(parent: controller, curve: Curves.easeOut);
Animation<int> alpha = new IntTween(begin: 0, end: 255).animate(curve);
```

上面代码构建了一个控制器，一条曲线，和一个 Twwen；



### 动画的基本结构

