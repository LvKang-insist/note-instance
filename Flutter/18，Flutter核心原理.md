## Flutter UI 系统

我们经常提到 UI 系统这个概念，UI 系统特指：基于一个平台，在此平台上实现的一个 GUI 系统，如 Android，IOS 等。我们说过各个平台的 UI 系统原理是想通的，也就是说无论是 Android 还是 IOS ，他们将一个界面显示到 屏幕上的流程是相似的，所以在介绍 Flutter UI 之前，我们先看看 UI 系统的基本原理，这样可以帮助读者对操作系统和系统底层 UI 有一个清晰的认识。



### 硬件绘制基本原理

我们知道屏幕是由一个个物理显示单元组成，每一个单元可以称为一个像素点，每一个像素点都可以发出多种颜色，显示器的成像原理就是在不同的物理像素点上显示不同的颜色，最终就会构成完整的图像

一个像素可以发出多少种颜色总数是一个非常重要的指标，比如我们所说的 1600万色的屏幕就是指一个像素点可以发出 1600 万种颜色，而显示器的颜色是由 RGB 三基色组成，所以 1600 万即2的24次方，即每个基本色 R,G,B 深度扩展至 8 bit(位)，颜色越深，所显示的色彩就更加丰富艳丽。

为了更新显示动画，显示器是以固定的刷新率刷新(从 GPU 取数据)，如一部手机的刷新率是 60Hz。当绘制下一帧是，显示器会发出一个垂直同步信号(如 VSync)，每 60 Hz 就会发出这样的信号。这个信号主要是用于同步 CPU ，GPU 和显示器的。一般来说，计算机系统中，CPU ，GPU 和显示器以一种特定的方式工作：CPU 将计算好的显示内容提交给 GPU ，GPU 渲染后放入帧缓冲区，然后控制器按照同步信号从缓冲区取帧数据传递给显示器显示。

CPU 和 GPU 的任务是个有偏重的，CPU 主要用于基本数据和逻辑计算，GPU 主要执行和图形处理相关的复杂属性，如矩阵，几何变换，GPU 的主要作用就是确定最终传输给显示器的各个像素点的色值。



###  操作系统绘制 API 的封装

由于最终图形计算和绘制都是相应的硬件来完成的，而操作系统的指令都会有操作系统屏蔽。开发者不会直接面对硬件，操作系统屏蔽了这些底层硬件操作后悔提供一下 API 供系统之上的应用调用。但是对于开发者来说，直接调用这些操作系统提供的API是比较复杂和低效的，因为操作系统提供的API往往比较基础，直接调用需要了解API的很多细节。正是因为这个原因，几乎所有用于开发GUI程序的编程语言都会在操作系统之上再封装一层，将操作系统原生API封装在一个编程框架和模型中，然后定义一种简单的开发规则来开发GUI应用程序，而这一层抽象，正是我们所说的“UI”系统，如Android SDK正是封装了Android操作系统API，提供了一个“UI描述文件XML+Java操作DOM”的UI系统，而iOS的UIKit 对View的抽象也是一样的，他们都将操作系统API抽象成一个基础对象（如用于2D图形绘制的Canvas），然后再定义一套规则来描述UI，如UI树结构，UI操作的单线程原则等。



### Flutter UI 系统

我们可以看到，无论是 Android SDK 还是 IOS 的 UIKit 的职责都是相同的，他们只是语言的载体和底层的系统不同而已。那么可不可以实现一个系统：可以使用一种编程语言开发，然后**针对不同的操作系统 API 抽象一个对上接口一致，对下适配不同操作系统的中间层**，然后在打包编译时在使用相应的代码，如果可以做到，那么就可以使用一套diam来编写跨平台应用了。而 Flutter 的原理正是如此，他提供了一套 Dart Api，然后在底层通过 OpenGLide这种跨平台的绘制库(内部会调用操作系统 API ) 实现了一套代码跨多端。由于 Dart Api 也是调用的操作系统 API ，所以他的性能更接近原生。

> 注意，虽然 Dar 是先调用了 OpenGL，OpenGL 才会调用系统 API ，但是这仍然是原生渲染，应为 OpenGL 只是操作系统 API 的一个封装库，它并不像 WebView 渲染哪些需要 JavaScriipt 运行环境和 CSS 渲染器，所以不会有性能损失

Flutter 对应用开发者定义的开发标准我们已经非常熟悉了，简单的概括就是：组合和响应式，我们要开发一个 UI 界面，需要通过组合其他 widget 来实现，Flutter 中，一起都是 widget，当 UI 发生变化时，我们不会直接修改 DOM ，通过更新状态，让 Flutter 系统根据新的状态来重新构建 UI。

