### 可滚动组件

当组件内容超过当前显示视口(ViewPort)时，如果没有特殊处理，Flutter 就会提示 Overflow 错误，为此，Flutter 提供了多种可滚动组件，用于显示列表和长布局；

可滚动组件都直接或间接的包含一个 `Scrollable` 组件，因此他们都包含一些共同的属性：

```dart
Scrollable({
  ...
  this.axisDirection = AxisDirection.down,
  this.controller,
  this.physics,
  @required this.viewportBuilder, //后面介绍
})
```

- axisDirection：滚动方向

- physics：此属性接受一个 `ScrollPhysics  ` 类型对象，他觉得可滚动组件如何响应用户的操作，比如用户滑动完抬起手指后，继续执行动画；或者滑动到边界之后如何显示。默认情况下，Flutter 会根据具体的平台分别使用不同的 `ScrollPhysics  ` 对象，应用不同的显示效果，在 IOS 上会出现弹性效果，而在 android 上则会出现微光效果，如果你想在所有的平台下使用同一个效果，可以显式的指定一个固定的 ScrollPhysics 。Flutter SDK 中包含了两个 `ScrollPhysics` 的子类，他们可以直接使用

  - ClampingScrollPhysics：Android 下微光效果
  - BouncingScrollPhysics：IOS 下 弹性效果

- controller：此属性接受一个 `ScrollController` 对象，该对象的主要作用是控制滚动位置和监听滚动事件

  默认情况下，Widget 树中会有一个默认的 `PrimaryScrollController` ，如果子树中的滚动组件没有显示的指定，则会使用这个默认的。

  这种机制带来的好处是父组件可以控制子树中可滚动组件的滚动行为，例如，Scaffold 正是使用这种机制在 IOS 上实现了点击导航栏回到顶部的功能

#### Scrollbar 

Scrollbar 是一个 Material  风格的滚动指示器(滚动条)，如果要给可滚动组件添加滚动条，只需要将 Scroolbar 作为可滚动组件的任意一个父级组件即可，如：

```dart
Scrollbar(
  child: SingleChildScrollView(
    ...
  ),
);
```

Scrollbar 和 CupertinoScrollbar 都是通过监听滚动通知来确定滚动条的位置的

#### CupertinoScrollbar

CupertinoScorllbar 是 IOS 风格的滚动条，如果你是用的是 Scrollbar，那么在 IOS 平台会自动切换为 CupertinoScrollbar

#### ViewPort 视口

在很多布局中都有 ViewPort 的概念，在 Flutter 中，术语 ViewPort (视口) ，如无特别说明，则是指一个 Widget 的实际显示区域；

例如，一个 ListView 的显示区域的高度是 800 像素，虽然其列表项总高度可能远远超过 800 像素，但是 ViewPort 任然是 800 像素

#### 基于 Sliver 的延时构建

通常可滚动的组件会非常多，占用的总高度也会非常大；如果一次性将子组件全部构建出将会非常昂贵！

为此，Flutter 中提出了一个 Sliver(薄片) 概念，只有当 Sliver 出现在视口时才会去构建他，这种模型也被称为 `基于 Sliver 的延时构建模型` 。可滚动组件中有很多都支持 Sliver 的延时构建模型，如 `ListView`，`GridView` ，但是也有不支持改模型的 `SingleChildScrollView`

#### 主轴和纵轴

在滚动组件的坐标描述中，通常滚动的方向称为主轴，非滚动方向称为 纵轴。由于可滚动组件的默认方向一般都是沿垂直方向，所以默认情况下主轴就是指垂直方向，水平方向同理

___

### SingleChildScrollView

`SingleChildScrollView` 类似于 Android 中的 `ScrollView` ，它只能够接受一个子组件，定义如下：

```dart
SingleChildScrollView({
  this.scrollDirection = Axis.vertical, //滚动方向，默认是垂直方向
  this.reverse = false, 
  this.padding, 
  bool primary, 
  this.physics, 
  this.controller,
  this.child,
})
```

除了上面说过的以外，重点看一下 `Reverse` 和 `primary` 两个属性

- reverse：官方文档的解释是：是否安州阅读相反的方向滑动，如 `scrollDirection` 值为 `Axis.horizontal` ，如果阅读方向是从右到左(取决于语言环境，阿拉伯语就是从右到左)。`reverse` 为 true 时， 滑动方向就是从右往左。

  其实此属性的本质上是决定可滚动组件的初始滚动位置是在 `头` 还是在 `尾` ，如 false 时，初始位置在头，反之则在 尾

- primary：指是否使用 widget 树中默认的 `PrimaryScrollController` ,   当滑动方向为垂直方向 (ScrollDirection 值为 Axis.vertical ) 并且没有指定 controller 时，primary 默认为 true。

  需要注意的是，通常 `SingleChildScrollView` 只应用在期望内容不会超过屏幕太多时使用，这是因为  `SingleChildScrollView` 不支持 Sliver 的延时实例初始化模型，所以如果预计视口可能包含超出屏幕尺寸太多内容时，那么使用 `SingleChildScrollView` 将会非常昂贵(性能差)，此时应该使用一些支持 Sliver 延时加载的可滚动组件，如 ListView

#### 栗子

```dart
class SingleChildScrollViewTest extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    String str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    return Scrollbar(
      child: SingleChildScrollView(
        padding: EdgeInsets.all(16),
        child: Column(
          children: str.split("").map((e) => Text(e,textScaleFactor: 2,)).toList(),
        ),
      ),
    );
  }
}
```

<img src="https://gitee.com/lvknaginist/pic-go-picure-bed/raw/master/images/20210307225604.gif" alt="345" style="zoom:50%;" />



___

### ListView

ListView 是最常用的可滚动组件之一，他可以沿一个方向线性排列所有子组件，并且他也支持基于 Sliver 的延时构建模型，ListView 的定义如下：

```dart
ListView({
  ...  
  //可滚动widget公共参数
  Axis scrollDirection = Axis.vertical,
  bool reverse = false,
  ScrollController controller,
  bool primary,
  ScrollPhysics physics,
  EdgeInsetsGeometry padding,
  
  //ListView各个构造函数的共同参数  
  double itemExtent,
  bool shrinkWrap = false,
  bool addAutomaticKeepAlives = true,
  bool addRepaintBoundaries = true,
  double cacheExtent,
    
  //子widget列表
  List<Widget> children = const <Widget>[],
})
```

上面的参数分为两组：第一组是可滚动组件的公共参数，上面已经说过了；第二组是 ListView 各个构造函数( ListView 有多个构造函数) 的共同参数，我们需要重点看看这些参数：

- itemExtent：该参数如果不为 null，则会强制 `children` 的 长度为 `itemExtent` 的值；这里的长度指的是方向上子组件的长度，也就是说滚动的是垂直方向，则 `itemnExtent` 代表子组件的高度；如果是水平方向，则是子组件的宽度。

  在 `ListView ` 中指定 `itemExtent` 比让子组件自己决定吱声的长度会更有效，因为指定后，滚动系统可以提前知道列表的长度，而无需每次构建子组件是都去计算一下，尤其是在滚动位置频繁变化时（滚动系统需要频繁去计算列表的高度）

- shrinkWrap：是否根据子组件的总长度来设置 `ListView` 的长度，默认值为 false，默认情况下， ListView 会在滚动的方向尽可能的占用更多的空间。当 `ListView ` 在一个无边界(滚动方向上)的容器中时， `shrinkWrap` 必须为 true

- addAutomaticKeepAlives：该属性表示是否将列表项（子组件） 包裹在 AutomaticKeepAlive 组件中；

  典型的，在一个懒加载的列表中，如果将列表包裹在 AutomaticKeepAlive 中，在改了吧划出视口时，他也不会被 GC 回收(垃圾回收)，他会使用 `KeepAliveNotification` 来保存其状态。如果列表项自己维护其 KeepAlive 状态，则此参数必须为 false

- addRepaintBoundaries：表示该属性表示是否将子组件包裹在 `RepaintBoundary` 组件中，当可滚动组件滚动时，被包裹的可以避免列表重绘，但是列表重绘的开销非常小(如一个颜色块，或者一个较短的文本) 时，不添加 `RepaintBoundary` 反而会更加高效。和 `addAutomaticKeepAlive` 一样，如果列表项资金维护其状态，此参数必须置为 false

>注意：上面这些参数并非 ListView 特有，在有些滚动组件中可能也会拥有这些参数，他们的含义是相同的



#### 默认构造函数

默认构造函数有一个 children 参数，它接受一个 Widget 列表(List) 。这种方式只适合有少量的子组件的情况，因为这种需要将所有 children 都提前创建好（这需要大量的工作），而不是等子 widget 真正显示的时候在创建，也就是说默认构造函数构建的 ListView 没有应用基于 Sliver 的懒加载模型

实际上通过默认构造函数创建的 ListView 和使用 SingleChildScrolLView + Column 的方式没有本质区别，下面看一个栗子：

