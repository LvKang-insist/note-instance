- 反射是允许程序在运行时访问程序结构的一类特性

- 程序结构包括：类，接口，方法，属性等语法特性

Kotlin 字节做了一套反射API库，这个库需要进行依赖

```kotlin
implementation("org.jetbrains.kotlin:kotlin-reflect")
```

#### 反射的常见用途

- 列出类型的所有方法，属性，内部类等等
- 调用给定名称及签名方法或指定名称的属性
- 通过签名信息获取泛型实参的具体类型
- 访问运行时注解及其信息完成注入或者配置操作

#### 反射常用的数据结构+

| 数据结构  | 概念及说明使用                                               |
| --------- | ------------------------------------------------------------ |
| KType     | 描述未擦除的类型或泛型参数等，例如Map<String,Int>；可以通过typeOf或者一些类型获取对应父类，属性，函数参数等 |
| KClass    | 描述对象的实际类型，不包含泛型参数，例如 Map；可通过对象，类型名直接获得 |
| KProperty | 描述属性，可通过属性引用，属性所在类的 KClass 获取           |
| KFunction | 描述函数，可通过函数引用，函数所在类的 KClass 获取           |

#### 获取泛型实参

```kotlin
fun main() {
    /**
     * declaredFunctions:获取该类中所有的函数
     * first：判断是否为指定的函数名，如果相等则返回出去
     * returnType：获取返回值
     * arguments：返回值的泛型
     */
    Api::class.declaredFunctions.first { it.name == "getUser" }
        .returnType.arguments.forEach {
        println(it.type)
    }

    //直接拿到函数引用，其他的和上面一样
    Api::getUser.returnType.arguments.forEach {
        println(it)
    }

    val subType = SubType()
    subType.typeParameter.let { println(it) }
}

class UserDTO

interface Api {
    fun getUser(): List<UserDTO>
}


abstract class SuperType<t> {
    val typeParameter by lazy {
        /**
         * 抽象类不能有实例，所以这里的 this 是子类的
         * supertypes：获取父类类型列表
         * first：获取第一个
         * arguments：拿到泛型
         * type：类型
         */
        this::class.supertypes.first().arguments.first().type!!
    }
    val typeParameterJava by lazy {

    }
}

class SubType : SuperType<String>()

```

