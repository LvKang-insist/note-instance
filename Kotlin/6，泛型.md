#### 泛型约束

```kotlin
fun <T : Comparable<T>> maxOf(a: T, b: T): T {
    if (a > b) {
        return a
    }
    return b
}

fun <T> callMax(a: T, b: T) where T : Comparable<T>, T : () -> Unit {
    a()
    b()
}
```





#### 泛型的型变

- 不变

  

- 协变

  父类出现的地方，可以使用代替。类似<? extends T>

  ```kotlin
  fun main() {
  
      val b = Box<Number>()
      b.a(Array<Int>(2, { 5 }))//error
  
  }
  class Box<E> {
  
      fun a(value: Array<E>) {
  
      }
  }
  ```

  因为 E 是 Number，所以传入 Int 肯定是错误的。修改如下：

  ```kotlin
  fun a(value: Array<out E>) {}
  ```

  out 代表协变，表示继承自 E 的都可以。这个时候传入 Int 就没问题了。因为 Int 是继承 Number 的。

- 逆变

  子类出现的地方，可以使用父类代替

  ```kotlin
  fun main() {
  
      val b = Box<Int>()
      b.b(Array<Number>(2, { 5 }))//error
  
  }
  
  class Box<E> {
      fun b(value: Array<E>) {
  
      }
  }
  ```

  E 是 Int，传入的是 Number。所以报错，修改如下

  ```kotlin
  fun b(value: Array<in E>) {}
  ```

  in 代表逆变，表示只要是 E 的父类都可以。所以传入 Number 就没问题了。Number 是 int 的父类

