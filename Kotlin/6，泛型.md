#### 泛型约束

```kotlin
fun <T : Comparable<T>> maxOf(a: T, b: T): T {
    if (a > b) {
        return a
    }
    return b
}

fun <T> callMax(a: T, b: T) where T : Comparable<T>, T : () -> Unit {
    a()
    b()
}
```





#### 泛型的型变

- 不变

  就是普通的泛型，传什么就是什么，只有一个类型

- 协变: out

  - 只读不写
  - 父类出现的地方可以用子类代替

  **只读不写：**

  ```kotlin
  val a: Array<out Number> = Array<Int>(2, { 3 })
  a[0]    //可读
  a[0] = 2 //ERROR
  ```

  ```kotlin
  open class W<out K> {
  	//Error 不可写
      fun add(k: K) {
  
      }
  	//可读
      fun get(): K? {
          return null
      }
  }
  ```

  

  **父类出现的地方，可以使用代替**。类似<? extends T>

  ```kotlin
  fun main() {
  
      val b = Box<Number>()
      b.a(Array<Int>(2, { 5 }))//error
  
  }
  class Box<E> {
  
      fun a(value: Array<E>) {
  
      }
  }
  ```

  因为 E 是 Number，所以传入 Int 肯定是错误的。修改如下：

  ```kotlin
  fun a(value: Array<out E>) {}
  ```

  out 代表协变，表示继承自 E 的都可以。这个时候传入 Int 就没问题了。因为 Int 是继承 Number 的。

  注意：

  ```kotlin
  class Box<E> {
  
      fun a(value: Array<out E>) {
          value[0] =1 //Error
      }
  }
  
  ```

- 逆变：in

  - 只写不读。某些情况可以读，但是只能往外取放在 Object 中

  - 子类出现的地方，可以使用父类代替
  
  **只写不读**
  
  ```kotlin
  val a: Array<in Int> = Array<Number>(2, { 3 })
  val s = a[0]  // 不能确定返回值的类型，只能使用Any类型接收
  a[0] = 2 
  ```
  
  ```kotlin
  open class W<in K> {
  
      //可写
    fun add(k: K) {
  
    }
  	//返回值 K 报错，不可读
      fun get(): K? {
          return null
    }
  }
  ```
  
  子类出现的地方，可以使用父类代替
  
  ```kotlin
  fun main() {
  
      val b = Box<Int>()
      b.b(Array<Number>(2, { 5 }))//error
  
  }
  
  class Box<E> {
      fun b(value: Array<E>) {
  
      }
  }
  ```
  
  E 是 Int，传入的是 Number。所以报错，修改如下
  
  ```kotlin
  fun b(value: Array<in E>) {}
  ```
  
  in 代表逆变，表示只要是 E 的父类都可以。所以传入 Number 就没问题了。Number 是 int 的父类
  
  注意：
  
  ```kotlin
   fun b(value: Array<in E>) {
          val s = value[0]    //不能确定返回值的类型，只能使用Any类型接收
  }
  ```
  
  

#### UnsafeVariance

违法形变约束

- 即声明为协变的类出现逆变，或者相反
- 声明为不变的类接收协变或者逆变类型的参数

```kotlin
class Dustbin<in T> {

    //报错，mutableListOf 本身是协变，但是传入的是逆变，所以报错。
    val list = mutableListOf<T>()

    fun put(t: T) {
        list += t
    }
    
}
```

修改如下：

```kotlin
val list = mutableListOf<@kotlin.UnsafeVariance T>()//使用注解，忽略形变即可
```

#### 星投影

- ‘*’ 可以用在变量类型的声明位置

- ‘*’ 可以描述一个未知的类型

- ‘*’ 所替换的类型在：

  - 协变点返回泛型参数上限类型
  - 逆变点接受泛型参数下限类型

- ```
  <p>对于 Foo <out T>，其中 T 是一个具有上界 TUpper 的协变类型参数，Foo <> 等价于 Foo <out TUpper>。 这意味着当 T 未知时，你可以安全地从 Foo <> 读取 TUpper 的值。</p>
  ```

- ```
  <p>对于 Foo <in T>，其中 T 是一个逆变类型参数，Foo <> 等价于 Foo <in Nothing>。 这意味着当 T 未知时，没有什么可以以安全的方式写入 Foo <>。</p>
  ```

- ```
  <p>对于 Foo <T>，其中 T 是一个具有上界 TUpper 的不型变类型参数，Foo<*> 对于读取值时等价于 Foo<out TUpper> 而对于写值时等价于 Foo<in Nothing>。</p>
  ```

  

out：当接收可协变的泛型参数(out T )时， *  映射的类型为 Any？

```kotlin
open class W<out K> {
	
    //Error
   /* fun add(k: K) {

    }*/

    fun get(): K? {
        return null
    }
}

fun main() {

    val w = W<Number>()
    val w1: W<*> = W<Number>()
    val s = w1.get() //返回类型为 Any?


}
```

下限：当接收可逆变泛型参数(in T) 时，* 映射类型为 Nothing。

注意：因为下限无法定义，所以所有的下限类型都为 Nothing

```kotlin
fun main() {

    val w = W<Number>()

    val w1: W<*> = W<Number>()
    w1.add("Nothing")//报错，只支持 Nothing

}

open class W<in K> {

    fun add(k: K) {

    }
}
```



#### 使用范围

- 不能直接使用或间接使用在属性和函数上

- 使用与作为类型描述时的场景，如类型实例化等

  

  