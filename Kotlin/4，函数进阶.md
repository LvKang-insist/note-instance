#### 高阶函数

​	参数类型包含了函数，或者返回类型为函数

 

```kotlin
fun needsFunction(block: () -> Unit) {
	//调用函数
    block()
}

fun returnsFunction(): () -> Long {
	//返回一个函数
    return { System.currentTimeMillis() }
}
```

#### 内联函数

​	当使用 Lambad 表达式时，他会被编译为一个匿名类。这表示每调用一次 lambad ，就会有一个额外的类被创建，这会带来运行的额外开销，导致 lambad 比使用一个直接执行相同代码的函数效率更低。

​	如果使用 inline 标记一个函数，这个函数被调用的时候编译器并不会生成函数的调用代码。而是 使用函数实现的真实代码替换每一次函数的调用

​	如下：

```kotlin
fun main() {
    cost {
        println("Hello")
    }
}

// 添加 inline 即为内联函数
inline fun cost(block: () -> Unit) {
    val start = System.currentTimeMillis()
    block()
    println(System.currentTimeMillis() - start)
}
```

​	反编译后如下

```kotlin
public static final void main() {
      int $i$f$cost = false;
      long start$iv = System.currentTimeMillis();
      int var3 = false;
      String var4 = "Hello";
      boolean var5 = false;
      System.out.println(var4);
      long var6 = System.currentTimeMillis() - start$iv;
      var5 = false;
      System.out.println(var6);
   }

```

​	  Lambad 表达式和 cost 的实现部分都被内联了。看起来是调用了 cost ，实际上是函数本身被内联到了调用处。

​		内联：

​		1，函数本身被内联到调用处

​		2，函数的函数参数被内联到调用处

内联函数的 return

```kotlin
val list = listOf<Int>(1, 2, 3, 4)
    list.forEach {
        if (it == 3) {
            //类似于 continue，退出本次
            return@forEach
        }
        println(it)
    }
```

**non-local return**

```kotlin
fun main() {
    //内联函数
    cost {
        println("Hello")
        return
    }
    println("not fond！")
}

inline fun cost(block: () -> Unit) {
    val start = System.currentTimeMillis()
    block()
    println(System.currentTimeMillis() - start)
}
//Hello
```

如果在 lambad 中使用 return 关键字，他会从调用处返回，而并非是lambda 中返回。因为这是一个内联函数，表达式中的内容相当于被提取到了调用的地方进行执行，所以就会在 main 中直接 return。

**从 lambda 中返回:**

```kotlin
fun main() {
    //内联函数
    cost label@{
        println("Hello")
        return@label
    }
    println("not fond！")
}
//Hello
//1
//not fond！
```

增加 label 标签后，就可以局部返回。

```kotlin

//定义 内联函数 添加 inline 即为内联函数
inline fun cost(crossinline block: () -> Unit): Runnable {
    return object : Runnable {
        override fun run() {
            block() //报错，因为 block 的调用处与定义处不在同一个调用上下文
            //添加 crossinline 关键字即可解决 ，禁止 non-local return
            //添加 noinlin 也可以解决，只不过 内联函数就没有意义了。
        }
    }
}
```

**内联属性**

```kotlin
var pocket: Double = 0.0
var money: Double
    inline get() {
        return pocket
    }
    inline set(value) {
        pocket = value
    }

```

和 内联函数一样，在调用 money 的时候会执行在调用的地方

内联函数的限制

1，public /protected 的内联方法只能访问对应类的 public 成员

2，内联函数的内联函数参数不能存储(赋值给变量)

3，内联函数的内联函数参数只能传递给其他内联函数参数



#### **几个有用的函数**

| 函数名 | 介绍                            | 推荐指数 |
| ------ | ------------------------------- | :------: |
| let    | val r = X.let{x -> R}           |   ★★★    |
| run    | val r = X.run{this.X ->R}       |    ★     |
| also   | val x = X.also{x -> Unit}       |   ★★★    |
| apply  | val x = X.apply{this:X -> Unit} |    ★     |
| use    | val r = Closeable.use{c -> R}   |   ★★★    |

​	let / run ：r  = lambda 表达式的返回值

​	alse / apply : x = receiver ,也就是当前的对象

​	use ：有些需要关闭的代码，如流，等可以在 Closeable 中执行，执行完后会自动关闭

```kotlin
class Person(var name: String, var age: Int)

fun main() {

    val person = Person("benny", 20)

    var y = person.let(::println)
    var x = person.run(::println)

    person.also {
        it.name = "张三"
    }

    person.apply {
        name = "李四"
    }

    File("build.gradle").inputStream().reader().buffered().use {
        //内部做了异常处理，流关闭。点击 use 查看源码
        println(it.readLine())
    }
}
```







- 高阶函数
  - 概念：参数类型包含了函数，或者返回值类型为函数。函数可被传递
  - 常见的高阶函数：forEach，map
  - 高阶函数的调用
- 内联函数
  - 内联的概念：将函数放在调用处执行，提高了性能
  - 内联函数的写法： inline
  - 高阶函数的内联
    - return
    - non-local-return
  - 内联属性
- 几个有用的函数
  - 按返回值的结果
    - let
    - run
  - 返回 Receiver
    - also 
    - apply
  - 自动关闭资源
    - use
- 