### 前言

Android 系统对每个app都会有一个最大的内存限制，如果超出这个限制，就会抛出 OOM，也就是Out Of Memory ，本质上是抛出的一个异常，一般是在内存超出限制之后抛出的。最为常见的 OOM 就是内存泄露(大量的对象无法被释放)导致的 OOM，或者说是需要的内存大小大于可分配的内存大小，例如加载一张非常大的图片，就可能出现 OOM。



### 常见的 OOM 

#### Java堆溢出

堆内存溢出是最为常见的 OOM ，通常是由于堆内存已经满了，并且不能够被垃圾回收器回收，从而导致 OOM。

#### 线程溢出

不同的手机允许的最大线程数量是不一样的，在有些手机上这个值被修改的非常低，就会比较容易出现线程溢出的问题

#### FD数量溢出

文件描述符溢出，当程序打开或者新建一个文件的时候，系统会返回一个索引值，指向该进程打开文件的记录表，例如当我们用输出流文件打开文件的时候，系统就会返回我们一个FD，FD是可能出现泄露的，例如输入输出流没有关闭的时候，[详细可参考 Android FD泄露问题](https://blog.csdn.net/ws6013480777777/article/details/84594116)

#### 虚拟内存不足

在新建线程的时候，底层需要创建 JNIEnv 对象，并且分配虚拟内存，如果虚拟内存耗尽，会导致创建线程失败，并抛出 OOM。



### Android 内存管理机制

Android 采用 ART/Dalvik 虚拟机**使用分页和内存映射**来管理内存，在回收方面，Dalvik 仅固定一种回收算法，而 ART 回收算法可在运行期按需选择，并且ART 具备内存整理能力，减少内存空洞，

#### Java内存区域

- 堆内存

    所有通过 new 创建的对象都会在堆内存进行分配，是虚拟机中最大的一块内存，也是gc需要回收的部分，同时OOM也容易发生在这里。

- 方法区

    存储被虚拟机加载的类信息，常量，静态变量等信息，这些所占据的内存永远不会被回收

- 栈区

    用来存放 java 方法执行时的所有数据，由栈贞组成，一个栈贞就代表一个方法的执行，每个方法的执行就相当于是一个栈贞在虚拟机中从入栈到出栈的过程。栈贞中主要包括，局部变量，栈操作数，动态链接等。

- 本地方法栈

    和栈区基本类似，只不过是给 native 层使用的

- 程序计数器

    用于记录线程执行的字节码指令地址，使得线程切换时能够恢复到正确的执行位置。

#### Android 获取内存限制大小

```kotlin
val manager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
manager.memoryClass
```

返回当前设备的近似每个应用程序内存类。这让你知道你应该对应用程序施加多大的内存限制，让整个系统工作得最好。返回值以兆字节为单位; 基线Android内存类为16 (恰好是这些设备的Java堆限制); 一些内存更多的设备可能会返回24甚至更高的数字。

我使用的手机内存是 16 g，调用返回的是 256Mb，