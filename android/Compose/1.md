### 简介

`Jetpack Compose` 是用于构建原生 Andorid 界面的新工具包，`Compose` 使用了更少的代码，强大的工具和直观的 Kotlin Api 简化并且加快了 Android 上界面的开发。

在 Compose 中，在构建界面的时候，无需在像之前那么构建 XML 布局，只需要调用 Jetpack Compose 函数来声明你想要的的元素，Compose 编译器就会自动帮你完成后面的工作。

在开始使用 Compose 之前，你需要重新搭建环境，可参考**[官方文档](https://developer.android.google.cn/jetpack/compose/setup)**



### 注解

- @Compose

  所有的组合函数都必须添加 `@Compose` 注解才可以。

  被 `@Compose` 注解的方法只能被同类型的方法调用。

- @Preview

  使用该注解的方法可以不在运行 App 的情况下就可以查看布局。`@Preview` 中常用的参数如下：

  1. `name: String`: 为该Preview命名，该名字会在布局预览中显示。

  2. `showBackground: Boolean`: 是否显示背景，true为显示。

  3. `backgroundColor: Long`: 设置背景的颜色。

  4. `showDecoration: Boolean`: 是否显示Statusbar和Toolbar，true为显示。

  5. `group: String`: 为该Preview设置group名字，可以在UI中以group为单位显示。

  6. `fontScale: Float`: 可以在预览中对字体放大，范围是从0.01。

  7. `widthDp: Int`: 在Compose中渲染的最大宽度，单位为dp。

  8. `heightDp: Int`: 在Compose中渲染的最大高度，单位为dp。

### Compose 编程思想







### 组合函数

`Jetpack Compose` 是围绕可组合函数构建的，这些函数就是要显示在界面上的元素，在函数中只需要描述应用界面形状和数据依赖关系，而不用去关系界面的构建过程，

如果需要创建组合函数，只需要将 `@Composeable` 注解添加到对于的函数上即可，需要注意的是组合函数的名称一般都是以大写字母开头的，如下：

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            PrimaryTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    Greeting("Android")
                }
            }
        }
    }
}

@Composable
fun Greeting(name: String) {
    Text(text = "Hello $name!", fontSize = 18.sp, color = Color.Red)
}

@Preview(showBackground = true)
@Composable
fun DefaultPreview() {
    PrimaryTheme {
        Greeting("Android")
    }
}
```

setContent 块 定义了 Activity 的布局，我们不需要去定义 XML 的布局内容，只需要在其中调用组合函数即可。

其中 Test 就是一个非常简单的可组合函数，里面定义了一个 Text，顾名思义，就是用来显示一段文本

并且，我们可以在 Test 函数上添加 @PreView 注释，这样就可以非常方便的进行预览



### 主题

```kotlin
//深色
val DarkColorScheme = darkColors(
    primary = Purple80,
    onPrimary = Color(0xFFFFFFFF),
    secondary = PurpleGrey80,
)

//亮色
val LightColorScheme = lightColors(
    primary = Purple40,
    onPrimary = Color(0xFF333333),
    secondary = PurpleGrey40,
)

@Composable
fun PrimaryTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {

    MaterialTheme(
        colors = LightColorScheme,
        typography = Typography,
        content = content
    )
}
```

默认的主题定义如上所示，最终会调用 `MaterialTheme`。

Material 主题主要包含三个属性，分别是 颜色，排版，和内容，Api 如下：

```kotlin
@Composable
fun MaterialTheme(
    colors: Colors = MaterialTheme.colors, // 颜色集合
    typography: Typography = MaterialTheme.typography, // 排版集合
    shapes: Shapes = MaterialTheme.shapes, // 形状集合
    content: @Composable () -> Unit // 要展示的内容
)
```

#### 颜色

```kotlin
class Colors(
    primary: Color, // 主颜色，屏幕和元素都用这个颜色
    primaryVariant: Color, // 用于区分主颜色，比如app bar和system bar
    secondary: Color, // 强调色，悬浮按钮，单选/复选按钮，高亮选中的文本，链接和标题
    secondaryVariant: Color, // 用于区分强调色
    background: Color, // 背景色，在可滚动项下面展示
    surface: Color, // 表层色，展示在组件表层，比如卡片，清单和菜单(CardView,SheetLayout,Menu)等
    error: Color, // 错误色，展示错误信息，比如TextField的提示信息
    onPrimary: Color, // 在主颜色primary之上的文本和图标的颜色
    onSecondary: Color, // 在强调色secondary之上的文本和图标的颜色
    onBackground: Color, // 在背景色background之上的文本和图标的颜色
    onSurface: Color, // 在表层色surface之上的文本和图标的颜色
    onError: Color, // 在错误色error之上的文本和图标的颜色
    isLight: Boolean // 是否是浅色模式
) 
```

更多的可以查看 `lightColorScheme` 函数。

#### 排版

```kotlin
@Immutable
class Typography internal constructor(
    val h1: TextStyle,
    val h2: TextStyle,
    val h3: TextStyle,
    val h4: TextStyle,
    val h5: TextStyle,
    val h6: TextStyle,
    val subtitle1: TextStyle,
    val subtitle2: TextStyle,
    val body1: TextStyle,
    val body2: TextStyle,
    val button: TextStyle,
    val caption: TextStyle,
    val overline: TextStyle
) 
```



#### 形状

```kotlin
class Shapes( 
    // 小组件使用的形状，比如: Button，SnackBar，悬浮按钮等
    val small: CornerBasedShape = RoundedCornerShape(4.dp),
    
    // 中组件使用的形状，比如Card(就是CardView)，AlertDialog等
    val medium: CornerBasedShape = RoundedCornerShape(4.dp),
    
    // 大组件使用的形状，比如ModalDrawer或者ModalBottomSheetLayout(就是抽屉布局和清单布局)
    val large: CornerBasedShape = RoundedCornerShape(0.dp),
)
```



#### 使用

```kotlin
setContent {
    PrimaryTheme {
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = MaterialTheme.color.background
        ) {
            Greeting("Android")
        }
    }
}
```

```kotlin
@Composable
fun PrimaryTheme(
    themeType: ThemeType = themeTypeState.value,
    content: @Composable () -> Unit
) {
    val shapes = Shapes(
        small = RoundedCornerShape(4.dp),
        medium = RoundedCornerShape(8.dp),
        large = RoundedCornerShape(12.dp),
    )
    MaterialTheme(
        colors = getThemeForTheme(themeType),
        typography = Typography,
        shapes = shapes,
        content = content
    )
}
```

另外，我写了一个可动态切换的主题，**[有兴趣的可以看一下](https://github.com/LvKang-insist/WanAndroid_Compose/blob/master/app/src/main/java/com/lvkang/wadandroid/ui/theme/ThemeManager.kt)**



### UI

#### SetContent

```kotlin
setContent {
    PrimaryTheme {
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = MaterialTheme.colorScheme.background
        ) {
            Greeting("Android")
        }
    }
}
```

同 Android 中的 SetContentView。

#### Theme

创建项目之后，就会生成一个 `项目名称+Theme` 的 `@Compose` 方法，我们可以通过更改其中的颜色来完成对主题的修改。具体如上面的主题所示.



#### Modifier

`Modifier` 本质是一个接口，可以用来修饰各种布局，例如 宽高，padding 等，常见的如下：

- padding：有四个重载方法
- plus：将其他的 `Modifer` 加入到当前的 `Modifer` 中。
- fillMaxHeight，fillMaxWidth，fillmaxSize：类似于 `match_parent`，填充整个父 Layout
- with，height，size ：设置宽高度
- rtl，ltr：开始布局的方向
- widthIn，heightIn，sizeIn 设置布局的宽度和高度的最大值和最小值
- gravity：元素的位置，
- 等等

需要注意的是 `Modifier` 系列的方法都支持链式调用



#### Column，Row

类似于 `LinearLayout`，` Column ` 是横向的，`Row` 是竖向的。有四个参数：

- `Modifer`： 具体值如上述所示

- `verticalArrangement`：子元素竖向的排列规则

  常见的就是，上下左右中，比较特殊的就是 

  `SpaceEvenly` 均匀分配，

  `SpaceBetween` 第一个元素前和最后一个元素后没有空隙，其他的按比例放入。

  `SpaceAround` 把整体中的一半空隙凭据放入第一个和最后一个的开始和结束，剩余的一半等比放入各个元素。

- horizontalAlignment：和上面一个，只不过方向不同

- content：要显示的内容

栗子：@Composable () -> Unit

```dart
setContent {
    PrimaryTheme {
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = MaterialTheme.colorScheme.background
        ) {
            Column {
                Row {
                    Button(
                        onClick = { themeTypeState.value = ThemeType.RED_THEME },
                        modifier = Modifier.width(100.dp),
                        colors = ButtonDefaults.buttonColors(containerColor = Color.Yellow)
                    ) {
                        Greeting(name = "按钮1")
                    }
                    Button(
                        onClick = { themeTypeState.value = ThemeType.GREEN_THEME },
                        modifier = Modifier.width(100.dp),
                        colors = ButtonDefaults.elevatedButtonColors()
                    ) {
                        Greeting(name = "按钮2")
                    }
                }
                Greeting(name = "Hello Android")
                Greeting(name = "Hello 345")
            }
        }
    }
}
```

![屏幕截图 2022-05-17 135439](https://cdn.jsdelivr.net/gh/LvKang-insist/PicGo/202205171356078.png)

#### Text

```kotlin
fun Text(
    text: String, //显示内容
    modifier: Modifier = Modifier, //修饰，可修改透明度，边框，背景等
    color: Color = Color.Unspecified, //文字颜色
    fontSize: TextUnit = TextUnit.Unspecified,// size
    fontStyle: FontStyle? = null, //文字样式，粗体，斜体等
    fontWeight: FontWeight? = null,//文字厚度
    fontFamily: FontFamily? = null,//字体
    letterSpacing: TextUnit = TextUnit.Unspecified, //用于与文本相关的维度值的单位。该组件还在测试中
    textDecoration: TextDecoration? = null,//文字装饰，中划线，下划线
    textAlign: TextAlign? = null,对齐方式
    lineHeight: TextUnit = TextUnit.Unspecified,//行高
    overflow: TextOverflow = TextOverflow.Clip,//如何处理溢出，默认裁切
    softWrap: Boolean = true,//是否软换行
    maxLines: Int = Int.MAX_VALUE,//最大行数
    onTextLayout: (TextLayoutResult) -> Unit = {},//计算布局时回调
    style: TextStyle = LocalTextStyle.current //文本的样式配置，如颜色、字体、行高等。
)
```

- modifier：在此处用来修饰 Text，Modifer 提供了很多扩展，如透明度，背景，边框等


 示例：

```kotlin
@Composable
fun Greeting(name: String) {
    Text(
        text = name,
        fontSize = 18.sp,
        fontWeight = FontWeight.Medium,
        color = MaterialTheme.colorScheme.primary,
        modifier = Modifier.height(30.dp)
    )
}
```



#### Button

```kotlin
fun Button(
    onClick: () -> Unit,//点击时调用
    modifier: Modifier = Modifier,//同上
    enabled: Boolean = true,//是否启用
    elevation: ButtonElevation? = ButtonDefaults.buttonElevation(),// z轴上的高度
    shape: Shape = FilledButtonTokens.ContainerShape.toShape(), 
    border: BorderStroke? = null,
    colors: ButtonColors = ButtonDefaults.buttonColors(),
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    content: @Composable RowScope.() -> Unit
)
```

- shape

  调整 button 的样式，例如 `RoundedCornerShape` 是圆角矩形的样式，`CircleShape` 是圆形的样式，`CutCornerShape` 是切角样式

- border

  外边框，默认是 null，Border 有两种使用方式，1 `Border(size: Dp, color: Color)`,2 `Border(size: Dp, brush: Brush)` 。

  第二种需要自己创建一个笔刷，去绘制外边框，例如要实现渐变的外边框。

- colors

  按钮的颜色，默认是 `ButtonDefaults.buttonColors()` 。可选的有：

  ![image-20220517151926468](https://cdn.jsdelivr.net/gh/LvKang-insist/PicGo/202205171519519.png)

​		其中可以设置按钮的背景色，未启用的颜色等。

栗子：

```kotlin
Button(
    onClick = { themeTypeState.value = ThemeType.GREEN_THEME },
    modifier = Modifier.width(100.dp),
    colors = ButtonDefaults.buttonColors(
        containerColor = Color.Yellow,
        contentColor = Color.Red,
        disabledContainerColor = Color.Black,
        disabledContentColor = Color.Green
    )
) {
    Greeting(name = "按钮2")
}
```

#### OutLinedButton

具有外边框的按钮，内部使用的也是 `Button`。默认会有一个边框，其参数和 `Button` 一致，效果如下

![image-20220517163336439](https://cdn.jsdelivr.net/gh/LvKang-insist/PicGo/202205171633495.png)

#### TextButton

默认的 button 在有主题的时候，默认背景是主题颜色，而 textButton 背景默认是透明的。`TextButton` 默认使用的颜色是 `ButtonDefaults.textButtonColors()`



#### Image

```kotlin
@Composable
fun Image(
    painter: Painter,
    bitmap: ImageBitmap, //
    contentDescription: String?,
    modifier: Modifier = Modifier,
    alignment: Alignment = Alignment.Center,
    contentScale: ContentScale = ContentScale.Fit,
    alpha: Float = DefaultAlpha,
    colorFilter: ColorFilter? = null
) 
```

- painter：图片资源，使用 PainterResource 来完成。
- contentDescription：无障碍提示文本信息
- contentScale ：类似于 ImageView 中的 scaleType 属性。
- colorFilter：将某种颜色应用到图片上
- alpha：不透明度

##### 示例

```dart
@Composable
@Preview
fun Image() {
    Image(
        painter = painterResource(id = R.drawable.one),
        contentDescription = "无障碍提示",
        contentScale = ContentScale.Crop,
        modifier = Modifier
            .width(100.dp)
            .height(100.dp)
    )
}

```

![image-20220517172753037](https://cdn.jsdelivr.net/gh/LvKang-insist/PicGo/202205171727140.png)

像一些圆图或者边框啥的就可以在 modifer 中直接设置了，如下：

```kotlin
@Composable
@Preview
fun Image() {
    Image(
        painter = painterResource(id = R.drawable.one),
        contentDescription = "无障碍提示",
        contentScale = ContentScale.Crop,
        modifier = Modifier
            .width(100.dp)
            .height(100.dp)
            .clip(shape = CircleShape)
            .border(2.dp, color = Color.Red, shape = CircleShape)
    )
}
```

![image-20220517173235028](https://cdn.jsdelivr.net/gh/LvKang-insist/PicGo/202205171732130.png)

##### 加载网路图片

加载网路图片需要借助第三方库 `coil`，使用方式如下：

```tex
//图片加载库
implementation("io.coil-kt:coil:2.0.0")
implementation("io.coil-kt:coil-compose:2.0.0")
```

```kotlin
@Composable
@Preview
fun Image() {
    AsyncImage(
        model = "https://img0.baidu.com/it/u=3147375221,1813079756&fm=253&fmt=auto&app=120&f=JPEG?w=500&h=836",
        contentDescription = "无障碍提示",
        contentScale = ContentScale.Crop,
        modifier = Modifier
            .width(100.dp)
            .height(100.dp)
            .clip(shape = CircleShape)
            .border(2.dp, color = Color.Red, shape = CircleShape)
    )
}
```



#### Spacer

和原生的一样，需要空白区域时可以使用 `Spacer` ，使用方式如下：

```kotlin
Spacer(modifier = Modifier.height(100.dp))
```



#### Surface

对内容进行装饰，例如设置背景，shape 等

```kotlin
fun Surface(
    modifier: Modifier = Modifier,
    shape: Shape = Shapes.None,
    color: Color = MaterialTheme.colorScheme.surface,
    contentColor: Color = contentColorFor(color),
    tonalElevation: Dp = 0.dp,
    shadowElevation: Dp = 0.dp,
    border: BorderStroke? = null,
    content: @Composable () -> Unit
) 
```

- color ：设置 `Surface` 的背景色，默认是主题中的 `surface` 颜色。
- contentColor：此 Surface 为其子级提供的首选内容颜色。默认为 [color] 的匹配内容颜色，或者如果 [color] 不是来自主题的颜色，这将保持在此 Surface 上方设置的相同值。
- tonalElevation：当 [color] 为 [ColorScheme.surface] 时，高程越高，浅色主题颜色越深，深色主题颜色越浅。
- shadowElevation：阴影大小



#### Scaffold

脚手架的意思，和 `Flutter` 中的 `Scaffold` 是一样的，通过 `Scaffold` 我看可以快速的对页面进行布局，例如设置导航栏，侧滑栏，底部导航等等。

```kotlin
fun Scaffold(
    modifier: Modifier = Modifier,
    topBar: @Composable () -> Unit = {},
    bottomBar: @Composable () -> Unit = {},
    snackbarHost: @Composable () -> Unit = {},
    floatingActionButton: @Composable () -> Unit = {},
    floatingActionButtonPosition: FabPosition = FabPosition.End,
    containerColor: Color = MaterialTheme.colorScheme.background,
    contentColor: Color = contentColorFor(containerColor),
    content: @Composable (PaddingValues) -> Unit
)
```

- topBar：Toolbar，常用的有 `CenterAlignedTopAppBar`,`SmallTopAppBar`，`MediumTopAppBar` 等。
- bootomBar：底部导航栏
- snackbarHost：
- floatingActionButton：按钮
- floatingActionButtonPosition：按钮位置
- containerColor：背景颜色
- contentColor：内容首选颜色

##### 看一个栗子：

```kotlin
Scaffold(
    topBar = {
       //.....
    },
    bottomBar = bottomBar,
) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(top = it.calculateTopPadding(), bottom = it.calculateBottomPadding())
    ) {
        content.invoke(it)
    }
}
```

需要注意的是，如果使用了 toolbar 或者 bootomBar，就会把 content 中的内容挡住，这个时候就需要使用 PaddingValue 设置内边距了。

还有一点须要注意，如果要使用沉浸式状态栏，就需要自定义 topBar 了，要不然状态栏会被 topBar 覆盖。下面代码是设置沉浸式状态栏的。

```kotlin
///系统 UI 控制器
implementation "com.google.accompanist:accompanist-systemuicontroller:0.24.8-beta"
//正确获取状态栏高度
api "com.google.accompanist:accompanist-insets-ui:0.24.8-beta"
```

```dart
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    WindowCompat.setDecorFitsSystemWindows(window, false)
    setContent {
        SetImmersion()
        PrimaryTheme {
            SetContent()
        }
    }
}


@Composable
private fun SetImmersion() {
    if (isImmersion()) {
        val systemUiController = rememberSystemUiController()
        SideEffect {
            systemUiController.run {
                setSystemBarsColor(color = Color.Transparent, darkIcons = isDark())
                setNavigationBarColor(color = Color.Black)
            }
        }
    }
}
```

##### 底部导航栏

```kotlin
@Composable
fun MainCompose(navController: NavHostController, mainBottomState: MutableState<Int>) {
    SetScaffold(
        bottomBar = {
            BottomBar(mainBottomState)
        }
    ) {
        when (mainBottomState.value) {
            0 -> HomeCompos(navController)
            1 -> ProjectCompos()
            2 -> FLCompos()
            else -> UserCompos()
        }
    }
}


@Composable
private fun BottomBar(mainBottomState: MutableState<Int>) {
    BottomNavigation(
        backgroundColor = MaterialTheme.colors.background,
    ) {

        navigationItems.forEachIndexed { index, navigationItem ->
            BottomNavigationItem(
                selected = mainBottomState.value == index,
                onClick = {
                    mainBottomState.value = index
                },
                icon = {
                    Icon(
                        imageVector = navigationItem.icon,
                        contentDescription = navigationItem.name
                    )
                },
                label = {
                    BottomText(
                        isSelect = mainBottomState.value == index,
                        name = navigationItem.name
                    )
                },
                selectedContentColor = Color.White,
                unselectedContentColor = Color.Black
            )
        }
    }
}

@Composable
fun BottomText(isSelect: Boolean, name: String) {
    if (isSelect) {
        Text(
            text = name,
            color = MaterialTheme.colors.primary,
            fontSize = 12.sp
        )
    } else {
        Text(
            text = name,
            color = Color.Black,
            fontSize = 12.sp
        )
    }
}
```

如果看的不是特别清楚，在最后我会贴出 github 地址，方便查看。



### 最后

到这里，这篇文章也完了。这篇文章主要讲了一下 `Compose` 中最基本的一些 UI 函数以及主题啥的。这也是我最开始接触到 `Compose` 学到的东西，所以这也算是我的学习笔记吧。

还有一个项目，目前只完成了一个最基本的架构。因为目前对状态以及生命周期啥的也不是特别了解，在页面跳转或者切换的时候，发现切换后对应的 Ui函数都会重组，之前的数据也没有了。接下来我会去看一下 `Compose` 中的状态如何管理，以及生命周期是什么样子的，然后慢慢的去完善这个项目。

[项目地址](https://github.com/LvKang-insist/WanAndroid_Compose)



> 
