

### 前言

可组合项 `应该没有附带效应`，但是，如果在对应用状态进行转变时需要使用可组合项。此时你应该使用 Effect API , 以便以可以预测的方式来执行这些附带消息

> 附带效应是指在可组合函数范围之外发生的应用状态变化



### LaunchedEffect

在某个可组合项的作用域内运行挂起函数。如果需要从组合项中安全带的调用挂起函数，请使用 `LaunchedEffect` 可组合项。

当 `LaunchedEffect` 进入组合时，他会启动一个协程，并将代码块作为参数传递。如果 `LaunchedEffect` 退出组合，协程将会取消。

如果使用不同的`键`重组 `LaunchedEffect` ，系统将取消现有的协程，并在新的协程中启动新的挂起函数。

例如在一个顶级的页面中进行网络请求，请求是通过 `LaunchedEffect` 中创建的协程来完成的，如果发生这个过程中函数重组了，协程也会相应的取消，并重新创建协程在重新执行。下面示例中将请求的结果当做成了`键`，这样当请求成功后，下次重组的时候也不会重新执行协程。如果重新重新获取数据，只需要修改 value 即可，例如示例中的按钮点击事件。

```kotlin
@Composable
fun HomeDetail() {
    val state = rememberUserState()

    LaunchedEffect(key1 = state) {
    	//模拟网络操作	
        delay(3000)
        state.value = MyUserState()
    }
    state.value?.run {
        Log.e("---345--->", this.name);
        Log.e("---345--->", this.toString());
        Scaffold() {
            Column() {
                Spacer(modifier = Modifier.padding(top = 50.dp))

                Button(onClick = {
                    state.value = MyUserState("张三",50)
                }) {
                    Text(text = "按钮")
                }
                Spacer(modifier = Modifier.padding(top = 100.dp))
                Text(text = "姓名 ${this@run.name}")
                Text(text = "姓名 ${this@run.age}")
            }
        }
    }


}

@Composable
fun rememberUserState(myUserState: MutableState<MyUserState?> = mutableStateOf(null)) =
    remember() {
        mutableStateOf(myUserState.value)
    }
}
class MyUserState(
    var name: String = "345",
    var age: Int = 20
)
```

另外，官方还提供了一种用法：

```kotlin
@Composable
fun MyScreen(
    state: UiState<List<Movie>>,
    scaffoldState: ScaffoldState = rememberScaffoldState()
) {

    // 如果 UI 状态包含错误，则显示提示栏
    if (state.hasError) {

        // `LaunchedEffect` 将取消并重新启动，如果`scaffoldState.snackbarHostState` 改变
        LaunchedEffect(scaffoldState.snackbarHostState) {
            // 使用协程显示snackbar，当协程被取消时snackbar 会自动关闭。当 `state.hasError` 为 false 时，此协程将取消，并且仅在 `state.hasError` 为 true（由于上述 if-check）或 `scaffoldState.snackbarHostState` 更改时启动
            scaffoldState.snackbarHostState.showSnackbar(
                message = "Error message",
                actionLabel = "Retry message"
            )
        }
    }

    Scaffold(scaffoldState = scaffoldState) {
        /* ... */
    }
}
```

在上面代码中，如果状态发生错误，则会触发协程，如果没有错误，将会取消协程。由于 `LaunchedEffect` 调用点在 if 语句中，隐藏当该语句为 false 时，如果`LaunchedEffect` 包含在组合中，则会被移除，隐藏协程将会被取消。

