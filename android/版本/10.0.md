	在 7.0 以前我们访问内存卡中的文件时可以通过 Uri.fromFile ，将 File 转换成 Uri 对象，这个 uri 对象表示这本地真实路径。

​	在 7.0 后，这种通过真实路径来获取的 Uri 被认为是不安全的，所以提供了一种新的解决方案，就是通过 FileProvide 来实现文件的访问，FileProvider 是一种比较特殊的内容提供器，他使用了类似于内容提供器的机制来对数据进行保护。

​	在7.0以前，访问一个图片如下所示：

```java
String fileName = "defaultImage.jpg";

File file = new File("文件路径", fileName);
Uri uri = Uri.fromFile(file);
```
​	7.0后，访问如下所示：

```java
File file = new File(CACHE_IMG, fileName);
Uri imageUri=FileProvider.getUriForFile(activity,"me.xifengwanzhao.fileprovider", file);//这里进行替换uri的获得方式
```

```java
 <provider
        android:name="android.support.v4.content.FileProvider"
        android:authorities="me.xifengwanzhao.fileprovider"//这里需要和上面部分字符串相同
        android:exported="false"
        android:grantUriPermissions="true">
        <meta-data
            android:name="android.support.FILE_PROVIDER_PATHS"
            android:resource="@xml/file_paths" />
    </provider>
```
```java
<resource xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path
        name="images"
        path="" />
        //path 表示共享的具体路径，这里为空表示整个SD卡进行共享
</resource>
```

---

​	然而上面这种真的好吗，对用开发者而且这算是好处吧，但是对用用户而言，上述的无疑一些流氓作用，因为开发者完全可以访问的内存中的所有位置，并作出一些改变，导致 SD 卡中的空间变得非常乱，即使卸载了 app,但是一些垃圾文件却还在内存中。

​	**10.0 中，为了解决上述问题， google 在 Android 10 中加入了作用域功能**

​	什么是作用域呢？就是 Android 系统对 SD 卡做了很大的限制，**从 10.0 开始，每个程序只能有权在自己的外置存储空间关联的目录下读取和创建相应的文件，也称作沙箱**。获取改目录的代码是：getExternalFilesDir() ，关联的目录路径大致如下：

```
/storage/emulated/0/Android/data/<包名>/files
```

​	将数据放在这个目录下，你可以使用之前的方法对文件进行读写，不需要作出任何变更和适配。但是这个文件夹中的文件会随着应用卸载而被随之删除。

​	那如果需要访问其他目录怎么办呢，比如获取相册中的图片，向相册中添加一张图片。为此，Android 系统针对系统文件类型进行了分类**：图片，音频，视频 这三类文件可以通过 MediaStore API 来进行访问，这种称为共享空间，其他的系统文件需要使用 系统的文件选择器来进行访问，**

​	另外，如果程序向媒体库写入图片，视频，音频，将会自动用于读写权限，不需要额外申请权限，如果你要读取其他程序向媒体贡献的图片，视频，音频，则必须要申请 READ_EXTERNAL_STORAGE 权限，WRITE_EXTERNAL_STORAGE 权限会在未来的版本中被废弃。

获取系统图片：

```kotlin
val cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null, null, "${MediaStore.MediaColumns.DATE_ADDED} desc")
if (cursor != null) {
    while (cursor.moveToNext()) {
        val id = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID))
        val uri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id)
        println("image uri is $uri")
    }
    cursor.close()
}
```



 适配要点：

- 打开相机

   1. 如果是10.0，需要根据共享文件创建一条图片地址的 Uri，用于保存拍照后的照片。

   2. 拍照完成后，拿到对应的 uri

   3. 如果要直接显示图片，则通过 uri 可直接加载

   4. 如果图片要上传，则需要将 uri 处理为一个 file 对象

      ​	在 10.0 中，只能访问沙箱文件和共享文件夹，需要注意的是：**共享文件夹可以通过 uri 进行访问，如拿到输入/输出流等。但是不能将其转为 file。因为就算是共享文件夹，也不能直接通过 file 进行访问。**

      ​	所以在图片上传的时候，**需要通过 contentProider 将 uri 转为一个 inputStream**，然后将数据读取出来，并且保存在沙箱文件中，然后在获取沙箱文件中的 file 即可。

      ​	注意，在拿到 uri 后可以对图片进行一些压缩处理。

- 打开相册

   1，直接通过 intent 打开相册

   2，拿到 返回的 uri 地址

   3，如果是10.0，则需要进行和 “打开相机” 中 3,4，同样的操作。

   

- 下载文件

   1，如果是 10.0，需要根据共享文件夹创建一条文件地址的 uri，用于保存文件

   2，通过网络操作，拿到对应的 inputSteam

   3，通过 contentProider 将 uri 转为一个 outputStream

   4，input 读取数据，output 写入数即可。

- 需要注意的

   - 只能在沙箱中操作 file 对象，切记。

   - 在对 图片进行复制和压缩上传的时候，需要注意耗时，如果太耗时，需要放在子线程中。

​	



