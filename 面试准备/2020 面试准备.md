- gc 回收机制

  当堆内存中某个区域没有被别的对象引用时，这个对象就会变为垃圾对象，等待垃圾回收器的回收

  垃圾收集算法

  - 引用计数法

    当一个对象被引用后，则引用计数 +1，失去引用 -1，当引用为 0 时可直接进行回收，但是这种是存在问题的， 如果两个对象之间互相引用，那么这两个对象将无法被回收。

  - 可达性分析

    从一个根对象开始向下搜寻，可以搜索到的都为活跃的对象，没有找的的则为无用对象，无用对象可能会被立即进行回收，也可能会进行其他操作，比如调用 finalize 方法，该方法会在对象被回收之前调用(java语言规范并不保证这个方法会一定执行)

     从这里可以引入四种引用类型等

  垃圾清理算法

  - 标记清除法

    从根集合中遍历所有引用，将不可达的对象进行标记，最后进行回收。缺点，会造成内存碎片

  - 标记整理法

    首先扫描不可达的对象并进行标记，然后扫描整个空间进行并进行整理，在整理的过程中清除标记的对象

  - 复制算法

    将可达的对象进行复制，然后将之前原来的对象进行回收即可。缺点，需要一个交换内存。

- java 内存区域

  - 堆内存

    所有通过 new 创建的对象都会在堆内存中进行分配，特点：是虚拟机中最大的一块内存，是 gc要回收的部分

  - 方法区

    存储被虚拟机加载的类信息，常量，静态变量等一系列在编译器需要保存的数据。方法区是永远占据内存的，也就是说他不会被回收

  - 栈区

    用来存放 java 方法执行时的所有数据，由栈贞组成，一个栈贞就代表一个方法的执行，每个方法的执行就相当于是一个栈贞在虚拟机中从入栈到出栈的过程。栈贞中主要包括，局部变量，栈操作数，动态链接等。

  - 本地方发栈

    和栈区基本类似，只不过是给 native 层使用的
  
  - 程序计数器
  
      用于记录线程执行的字节码指令地址，使得线程切换时能够恢复到正确的执行位置。
  
  

### 为什么要选用组件化

- 业务组件可独立运行，提高了编译运行效率
- 实现了业务之间的解耦
- 适合多人协同开发，每个人只需要负责自己的业务模块即可

组件化的分层

- 壳
- 业务组件层：对应每个业务的组件，这些组件是可以单独运行的
- 业务层：具体的业务模块，共有的base模块，路由模块等
- 组件层：独立出来的组件，不依赖于项目

### 聊一聊 Jetpack

JetPack 是 Android 官方提出的一个套件，里面包含了很多个库，主旨在于减少开发模板代码并且编写在各个版本中运行一致的代码，让开发者有时间和精力去编写重要的代码

JetPack 中包含了很多个库，其中常用的有 LiveData，ViewModel，Room等。

LiveData：livedata 是一种可观察的数据存储类。相比于其他的观察者，livedata 内部具有感知生命周期的能力，这种能力可以使得它只更新处于活跃状态的观察者。例如一般情况下在网络请求结束后需要判断当前的页面是否存在，如果不存在，则不会更新界面，但是这个操作就会显得很繁琐，而 livedata 则帮我们彻底的解决了这个问题。

LiveData 为什么可以帮我们解决内存泄漏

- livedata 会绑定到 lifecycle 对象，并在关联的生命周期结束时进行销毁
- 当观察着的生命周期处于不活跃的状态时，livedata不会进行数据的通知
- 当 观察这的生命周期处于活跃状态时，才会对观察者进行通知

ViewModel

ViewMode 是以注重生命周期的方式来存储和管理页面的数据，ViewModel 可以使页面发生旋转等操作后让数据继续留存。

- activity 被系统销毁或者需要重新创建的时候对需要 通过自身的 onSaveInstenceSata 方法进行保存，然后在 onCarete 中进行读取，而且数据量如果太大也就不太方便了
- activity 中难免有些异步调用，所以当 activity 销毁的时候，这些调用还在。这种就会导致内存泄漏或者崩溃

ViewModel 会在在 activity 销毁的时候调用 onCleared 方法，清理资源

ViewModel 还可以直接帮助 fragment 和 activity 进行通信，使用起来更加的方便简单

### 说一下你是如何做包大小治理的

- 代码优化

  - 三方库处理

    对于有相同功能的第三方库应该进行统一处理，如之前的人使用 picasso 处理图片，然后到下一个人之后他可能对 picasso 不太熟悉，然后又引入了 glide，就会导致项目存在多个相同功能的 sdk。一般来说，在项目中，需要将一些基础库机进行统一，比如说将图片加载库，网络库，数据库等进行统一，去掉沉余的库

  - 移除无用的代码

    移除无用代码的时候通常会遇到下面两个问题

    1，业务代码只增不减

    2，代码太大不敢删

    这里有一个很好的办法来判断那些那些类在线上环境下没有被用到，对于 activity 来说，其实非常简单，只需要监听一些他的创建，在 oncreate 中加上统计即可。没有被统计到的就说明他没有被使用

    还可以使用 as 自带的工具来检测那些代码没有被使用到

- 资源优化

  - 沉余资源优化
  - 重复资源优化
  - 图片压缩
  - 使用针对性的图片格式
  - 资源混淆
  - 统一应用风格

### 谈一谈你的性能优化都做了什么

- 启动优化

  对 applicaiton 中需要初始化的代码进行处理，

  - 对于可以在子线程中初始化的代码可以创建一个线程池进行并发的初始化，
  - 对于一些不是特别着急的 sdk 可以通过懒加载的方式进行初始化，即当 app 启动后在进行初始化
  - 然后将必须在 applicaiton 且 不能再子线程初始化的代码 进行初始化

  对于第一个 MainActivity 进行处理

  尽量在 onCreate 到 onResume 之间不要做大量的页面处理，可以采用懒加载的方式进行处理。上一个项目就是由于 MainActivity 启动时间太长导致页面迟迟不能显示出来。最终解决的方法就是使用懒加载进行处理，还有延迟处理等，可以在 页面 resume 之后再进行和页面的处理

- 布局优化

  - 过度绘制，可以在开发者模式中打开过度绘制，解决

    移除布局中一些不必要的背景

    减少布局的嵌套层级，如果布局使用了嵌套的 lienarlayout就会导致布局的层次抬升，如果使用了 layout_weight ，就会导致每个子 View 要测量两次，并且这个布局在 recycler View 中使用就会导致大量的重复绘制

  - 尽量减少布局嵌套的层级，可使用 约束布局

  - 尽量减少使用相对布局，能使用 linearlayout 和 framelayout 就不要使用 recyclerview，

  - onDraw 方法中不做耗时任务，尽量不多做循环操作，特别是嵌套循环。

  - 在 onDraw 中不要创建对象，应该使用全局的对象，应为 onDraw 方法会被大量的调用，就意味着会产生大量的临时对象，甚至会导致 gc

  - 可以将 merge 和 include 配合使用，以减少层级，对于布局直接的分隔，可以使用 Speac  ，Speac 是非常轻量级的 view，内部不会进行任何的绘制

- 内存优化

  - 内存抖动

    在某一时间段内频繁的创建和回收对象被称为内存抖动，如在 onDraw  方法中创建对象，由于 onDraw 方法会被大量的调用，就会导致创建大量的对象，而 gc 机制则会在适当的时候去回收这些对象，这种重复创建和回收的过程称为内存泄漏。如果回收不及时就会导致内存溢出

  - 内存泄漏

    内存泄漏指的是一个本应该被销毁的对象无法被销毁

    - 集合造成的泄漏

      集合在使用完成后应该进行 clear 操作，否则该集合会一直持有元素对象的引用，导致对象无法被回收

    - 单例类泄漏

      单例的生命周期会和程序的周期一样长，所以单例中不应该引用比自己生命周期短的对象，例如 单例中持有 activity 引用，导致 activity 不能被回收。

    - 匿名内部类造成的泄漏

      静态的内部类和外部类是没有引用关系的，所以在使用静态内部类的时候尽量不要给他传入外部类的实例

      普通的内部类默认会持有外部类的强引用，被调用时需要外部类的实例，可以直接访问外部类的方法和变量。如果某个类持有者内部类的引用，那么这个时候外部类是无法被回收的，这个时候可能会造成内存泄漏

      例如：

      ​	在 activity 中创建了一个 handler 对象，并实现了他的 handlerMessage 方法，在使用handler 发送消息之后 activity 执行了 finish 方法进行销毁，这个时候 因为message 持有者 handler 的引用，而handler 的外部类又是 activity，就会导致 activity 无法被回收。

      解决：1，在 destory 中执行 removeCall... 方法，将 message remove 掉即可

      ​		   2，使用 静态内部类 + 弱引用的方式

    - 资源文件造成的内存泄漏，注销广播，关闭 io，停止 动画等。

  - 内存溢出

    如果内存泄漏没有被处理，且经常出现，就会导致很多对象无法被回收，最终导致内存溢出。解决的办法就是解决内存泄漏

### SparseArray 和 HashMap 的区别

HashMap：内部采用数组 + 链表，默认大小为 16，也就是说每创建一个 map，即使不用，也会分配一块内存给他。

SparseArray ：内部采用 数组 + 数组的方式，key必须是 int 类型。他比 hashMap 更省内存，主要是因为他避免了对 key 的自动装箱，使得单个元素的存储成本下降，get 和 set 内部使用的都是二分查找法，也就是说内部的 key 在数组中的排列方式是有序的

优势：1，避免了自动装箱，2，没有额外的结构体，单个元素的存储成本下降，3，数量小的情况下，访问的效率就越高

缺点，在数据量大的时候优势就不太明显了。

所以如果要使用 SparseArray，数量量最好在 千以内，并且 key 为 int 类型。

### 四大组件

- Service、

  start启动：onCreate -> onStartCommand -> onDestory

  bind启动：onCreate -> onBind -> onUnBind ->onDestory

  区别：start 启动后和调用者没有任何关系，即使 页面销毁，服务也会存在

  ​		   bind 启动后可以和 activity 进行通信，页面销毁，服务也会被销毁

   		

- activity 生命周期

  onCreate -> onStart -> onResume -> onPause ->onStop -> onDestory

  跳转页面 ：A调用 onPause，B 调用 onCreate -> onStart -> onResume ，A 调用 onStop

  返回页面 ：B 调用 onPause，A 调用 onRestart -> onStart -> onResume ，B 调用 onStop -> onDestory 

- 广播

  标准广播 ：完全异步执行的广播，发出广播后，所有的接受者几乎会同一时间接收到这个广播，这种效率高，但是无法被打断

  有序广播：是一种同步执行的广播，具有优先级，可被打断，可以选择是否截断此广播，截断后后面的接受者无法接收到广播

  本地广播：只能被当前应用程序接受的广播

  注册方式有两种：1，静态注册，直接在清单文件注册；2，动态广播，在代码中进行注册

  区别

  - 动态比静态的安全
  - 静态在 app 启动时初始化，动态在代码中初始化
  - 静态的生命周期比动态的长
  - 动态广播的优先级比动态的高

- ContentPrivider

  用于为不同应用之间的数据共享，并提供了统一的接口，ContentPrivider 通过 uri 来标识其他应用要访问的数据，通过 ContentResolver 的增删改查方法来实现对共享数据的操作

### 编译版本，最小版本和目标版本

- compiledSdkVersion ：编译版本，用于指定当前项目的编译版本，项目使用哪个版本就会使用哪个版本的 api，因此 google 建议我们使用最新的版本
- minSdkVersion ：项目最低建议的 Android 系统的版本
- targetSdkVersion：项目的兼容版本，例如兼容版本为 21，那么项目就不需要进行权限检测

### Android 版本之间的差异

- 6.0 ：增加了运行时权限
- 7.0 ：增加了应用分屏，通知栏快捷回复
- 8.0 ：重新设计了通知，增加了通知渠道，允许为要显示的通知创建用户可自定义的渠道，用户界面讲这种称为通知类别。增加了画中画模式
- 9.0：增加了显示缺口的支持，如刘海屏等
- 10.0 ：对于隐私进行了重大更新，如 设备 id 不能随便获取，进行分区存储，禁止后台启动 activity。增加了深色模式

### 说一下 TCP 的三次握手的原因是什么

1，首先客户端发送 syn 码到服务器，

2，服务器接收到后会发送 syn + ack 到客户端，意思是已经收到 客户端的消息了，可以建立连接

3，客户端收到后消息后会在发送一个 ack 消息，告诉服务器我也准备好了，可以进行通信

原因：

- 建立可靠的连接

### 使用 WebView 要注意的问题

- 关于内存泄漏

  1，当使用 webview 的时候，最好单独开启一个进程去使用 webview，并且当这个进程结束时手动调用 System.exit(0)。这是目前最好的解决方案，使用此方法 webview 所引发的资源无法释放的问题都可以解决

  2，动态的添加 webview，对传入 webview 中content 使用弱引用。动态添加指的是在 activity  启动完成后将 webview 动态的 add 到 布局中，在 activity 销毁时 remove调 webview，在调用 webview 的 removeViews 即可

- 后台无法释放 js 导致耗电

  如果 webview 加载的 html 中有一些动画之类的东西，如果此刻 webview 处于后台，这些资源是不会被释放的，用户无法感知，导致 耗电特别快，

  对于这种情况，需要在 onstop 和  onresume 方法中调用 setJavaScriptEnabled j将其设置为 false 和 true。

### android 帧动画

- 帧动画是由一组图片集合而成，是具有动画效果的图片资源
- 因为帧动画是由图片组成，当图片数量过多并且并且比较大的时候就会比较容易出现 OOM 的问题。所以应该避免使用帧动画

#### 接口和抽象类的区别

- 接口中可以包含抽象方法，静态方法和私有方法，不能为方法提供默认的实现；抽象类则可以对方法进行默认的实现
- 接口中可以定义静态常量，如果要定义变量，必须显式的进行初始化。抽象类中无需显式的初始化
- 接口中不包含构造器；抽象类中可以包含构造器，抽象类中的构造器不是用来直接 new 对象，而是子类继承后需要调用构造器完成一项初始化的操作
- 接口中不能包含初始化块，抽象类可以
- 一个类可以实现多个接口，但是只能继承一个抽象类。
- 抽象类不可以被实例化，是因为抽象类必须具有具体的属性和方法。

### 工厂模式

简单工厂

- 定义一个工厂类，根据传入的参数返回不同的实例，这些被创建的实例都具有共同的父类或者实现了同一个接口

工厂方法模式

- 定义一个用于创建对象的接口，让子类去决定要实例化哪个类。

  案例：加载图片

  1，定义一个加载图片的接口，内部有一个加载图片的方法。然后由子类进行实现，如 加载 png 格式图片，gif 格式等

  2，创建一个获取工厂的接口，内部定义一个方法，返回加载图片的接口。然后子类进行实现，每个工厂对应着不同格式的图片加载

  3，使用的时候直接创建对应的工厂，然后调用工厂里面的方法，即可完成图片加载

### 观察者模式

​	定义了一种一对多的依赖关系，让多个观察者同时去监听某一个主题，当主题发生改变的时候，这些观察者会得到通知，使这些观察者可以自动更新

### Kotlin 中的密封类

密封类是一种特殊的抽象类，不能被实例化，但是可以有抽象成员

密封类的子类是可数的，他的子类必须定义在自身的文件中

与枚举相比：枚举是实例可数，密封类 是子类可数

### 如何自定义一个线程池

通过 ThreadPoolExecutor 来自定义线程池，可以指定核心线程数量，最大线程数量，非核心线程数量，非核心线程限制的超时时长，线程池中的队列等参数

线程池添加任务的流程

- 判断线程池是否处于运行状态，如果线程非运行状态，则会拒绝
- 判断线程数量是否小于核心线程数量 ，如果小于，创建新的工作线程并且提交任务，
- 如果大于核心线程数量，那么任务会被添加到阻塞队列中进行排队
- 如果阻塞队列达到上限，就会判断当前线程数是否小于最大线程数量，则会启动一个非核心线程来执行任务
- 如果大于最大线程数量，则该任务会被拒绝

### java 和 Kotlin 的区别

- 扩展函数，函数式编程
- 智能类型转换
- 字符串模板
- 变量类型的推断，
- 区间表达式，
- 伴生对象，单例类，密封类，数据类
- 协程