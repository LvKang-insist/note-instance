# 19/9-9

​	上班的一周后，今天正式开始添加功能了，是一个二手车鉴定，总的来说不是太复杂，但是因为项目不太熟悉的缘故，所以没有做出来。明天开始，每天在 Type 打卡，每日一个面试题，每天都需要掌握新知识。就这样了。

# 19/9-10

#### 什么是悲观锁和乐观锁？ 

锁是为了避免自己在修改资源的时候，别人同时在修改，导致同一时间产生两份修改，不知道如何处理的情况而设置的独占资源，避免多个操作同时处理同一资源的技术。

乐观锁：默认为，某个线程在自己处理共享资源的时候，不会出现同一时刻来修改此资源的前提，只在处理完毕，最后写入内存的时候，检测是否此资源在之前未被修改。类似于读写锁的读锁就是乐观锁。

悲观锁：默认为，某个线程在自己处理共享资源的时候，一定会出现同一时刻来修改此资源，所以刚拿到这个资源就直接加锁，不让其他线程来操作，加锁在逻辑处理之前。类似，synchronized关键字，条件锁，数据库的行锁，表锁等就是悲观锁。

#### 日志

工作 上完成商品鉴定页面的ui，使用 RecyclerView 的第三方适配器，实现了 多级列表。

修改mvp 框架，碰到一个问题，在使用 navigation 时发现 好像不能从当前碎片跳转到子碎片。暂时没有找到解决办法。想象是否可以在创建一个 xml 文件管理子碎片

# 19/9-11

#### java 中 IO 流分为几种?BIO,NIO,AIO 有什么区别?

​	Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的.

​	BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。

BIO是一个连接一个线程。
NIO是一个请求一个线程。
AIO是一个有效请求一个线程。

- BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
- NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
- AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

#### 日志

工作上完成了二手鉴定店铺的详情界面，并进行了数据的对接，完成了提交订单界面的构建和数据。明天实现提交订单的功能。

在使用 Navigation 时发现他的局限性有点大，比如无法添加子碎片，在子碎片中无法切换父碎片等。查了资料，没找到处理方法，不知道是我没查到还是没有。考虑是否需要 取消使用 Navigation。

睡觉 。。。。。。

# 19/9-22

​	中间有点时间耽搁了。没写，从今天开始恢复正常

####  	首先写一下工作时apk的发布流程


	1，获取上一个版本
	2，修改接口地址， 正式版的 url为：
			 public static final String BASE_URL = "https://www.4sno1.com/JSCM/";//1.2.4
			 public static final String BASE_URL_HTML = "https://www.4sno1.com/";
	
			 pd 是 打包测试用的
			 public static final String BASE_URL = "https://www.nuli100.com/JSCM_PD/" //1.5.4	
			 public static final String BASE_URL_HTML = "https://www.nuli100.com/	
	
			 下面这个是公司内部使用的
			 public static final String BASE_URL = "https://www.nuli100.com/JSCM/";//1.3.1
			 public static final String BASE_URL_HTML = "https://www.nuli100.com/"
	
			 最后就是测试用的
			 public static final String BASE_URL = "http://192.168.199.196/JSCM/";
	    		 public static final String BASE_URL_HTML = "http://192.168.199.196";
	3，修改版本
		
		首先确定要发布的是否为正式版，如果是正式版,首先确定上一个版本号，然后将versionName进行 +1，versionCode 也 +1. 如果是需要打包测试，则使用上面的pd url。然后将 versionName 进行+1，versionCode 不需要动。versionCode 只是在发布正式版的时候需要+1.
	
	4，进行加固
		如果是打包进行测试的则不需要进行加固。
		如果是正式版，则需要进行加固。目前需要使用的加固为 乐加固 和 360加固。注意乐加固会生成俩个apk，我们需要的是哪个最后面为 signed 的apk，在加固的时候一定要注意签名，因为 有两个app 的签名文件，如果选择错了，会导致 app 不能进行升级等一系列的问题。所以在进行加固的时候 一定要让签名文件和app 相对应。
	5，发布
		直接发给后端。
# 19/9-23

#### 	正确判断当前的 fragment 是显示还是隐藏

​	1、当Fragment配合ViewPager使用时，使用setUserVisibleHint()判断Fragment是显示还是隐藏。  
​	2、当Fragment配合FragmentTransition使用时，使用onHiddenChanged()来判断Fragment是显示还是隐藏，但是第一次显示要在onResume()里判断。

#### 修改 TabLayout 的下划线宽度

​	修改下划线的宽度没有给定的api，但是可以通过反射去修改，如下所示：

```java
// 设置TabLayout下划线长度
	public static void setIndicator(TabLayout tabs, int leftDip, int rightDip) {
		Class<?> tabLayout = tabs.getClass();
		Field tabStrip = null;
		try {
			tabStrip = tabLayout.getDeclaredField("mTabStrip");
		} catch (NoSuchFieldException e) {
			e.printStackTrace();
		}

		tabStrip.setAccessible(true);
		LinearLayout llTab = null;
		try {
			llTab = (LinearLayout) tabStrip.get(tabs);
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}

		int left = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, leftDip, Resources.getSystem().getDisplayMetrics());
		int right = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, rightDip, Resources.getSystem().getDisplayMetrics());

		for (int i = 0; i < llTab.getChildCount(); i++) {
			View child = llTab.getChildAt(i);
			child.setPadding(0, 0, 0, 0);
			LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT, 1);
			params.leftMargin = left;
			params.rightMargin = right;
			child.setLayoutParams(params);
			child.invalidate();
		}

	}
```

使用的时候直接调用即可。

#### Intent 传输的数据有大小限制吗？如何解决

​	Intent 传输数据的消息受 Binder 限制，上限 1M ，不过这个 1M 并不是安全的上限，Binder可能在处理别的工作，安全上限是多少在不同的机型上也不一样

​	传 512K 以下的数据可以正常传递

​	传512 -- 1024K 的数据可能会出错，闪退

​	传1M 以上的数据会报错：TransactionTooLargeException

​	考虑到Intent 还要包括启动 Activity 等信息，实际传输大小可略小于 512K

​	解决办法

​	1，减少数据传输量

​	2，Intent 通过绑定一个 Bundle 传输，这个可以超过 1M，不过也不能过大

​	3，通过内存共享，使用静态变量或者使用 EventBus 等类似的通信工具

​	4,通过文件共享

# 2019/9-24

#### 为什么要将 String 设计为不可变

​	1，字符串常量池的需要

​			当创建一个 String 对象时，如果此字符串已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象

​			如果允许改变，那么将导致各种逻辑错误，比如改变一个对象将会影响另一个独立对象，严格来说，这种常量池的思想是一种优化手段

​	2，允许String对象缓存 HashCode

​			java 中 String 对象的哈希码会被频繁的使用，比如在 hashMap中。字符串的不变形保证了hash码的唯一性，因此可以放放心的进行缓存。这也是一种优化手段，意味着不必没说都计算新的哈希码。在 String 类中有 private int hash 来缓存hashcode

​	3，安全性

​			String 被许多的类来当做参数，如 网络url，文件路径path 等等，如果String 不是固定的，将会引起各种安全隐患

#### 	谈一谈插值器和估值器

​		1，插值器，根据时间（动画时长）流逝的百分比来计算属性变化的百分比，系统默认有匀速，加减速等

​		2，估值器，通过上面的插值器得到百分比计算出具体变化的值，系统默认有整形，浮点型，颜色估值器

​		3，自定义只需要重新他们的 evaluate 方法就可以了

#### android 10 的新特性

- 限制后台拉 activity
- 费系统应用无法获取到IMEI
- 外部存储的隔离存储，公共媒体文件的存储
- 后台地理位置权限
- 适配折叠屏
- 全面手势导航，应用充分利用全面屏，建议应用不要覆盖系统手势，否则可能导致手势冲突，影响用户使用习惯
- 应用使用黑色主题，灵活动态变化
- Android 10，受限制的非SDK接口增多了。

# 2019/9-25

​	今天请假办理离校手续

​	晚上修改mvp里面的bug，还没有完全修复。