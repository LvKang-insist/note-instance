#  19/5-6：

### 请简述 LinkedHashMap 的工作原理和使用方式？

​	LinkedHashMap 是继承自 HashMap 实现Map接口，

​	LinkedHashMap 和 HashMap 的主要区别就是 LinkedHashMap 是有序的，而 HashMap 是无序的。

​	LinkedHashMap 默认为插入的顺序，他是基于HashMap 和 双向链表实现的，LinkedHashMap 是线程不安全的。

### AsyncTask 启动的方式？

​	在SDK3.0以前的版本执行 asyncTask.execute(task)  时的确是多线程并发执行的，线程池大小为5，最大128个，google 在3.0以后做了修改 ，将 asyncTask.execute(task）修改为了顺序执行，即只有当一个任务完成后才执行下一个任务

​	那么怎么并发执行呢？很简单，3.0后新增了一个方法  executeOnExecutor(Executor exec ,Object... params)，该方法接收两个参数，第一个是 Executor ，第二个是任务参数，第一个是线程池实例，google 为我们定义了两种，第一种是AsyncTask.SERIAL_EXECUTOR ，第二种是AsyncTask.THREAD_POOL_EXECUTOR，顾名思义，第一种就是3.0 以后的方法，是顺序执行的，第二种就是3.0以前的 execute 方法，是可以并发执行的，我们直接用asyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, task);就可以多任务并发执行了。

​	自定义Executor

```java
private static ExecutorService exec = Executors.newSingleThreadExecutor();

//程序在每次调用时是使用的同一个Executor，
syncTask.executeOnExecutor(exec, task);

//当Executor类型为下面时 只有两个线程在执行任务
private static ExecutorService exec = Executors.newFixedThreadPool(2);
syncTask.executeOnExecutor(exec, task);

```

# 19/5-7

### 谈一谈JAVA 的垃圾回收机制？

垃圾回收机制：
当堆内存中的某块区域没有对象引用时，这个内存区域就会变成垃圾，等待垃圾回收器的回收，

怎么找到无用对象：

- 引用计数：最简单的寻找无用对象的机制，当一个对象被引用一次，引用计数+1，当失去引用时引用计数-1，当此对象引用计数为0时可以直接回收。这种方法有一个显而易见的问题：无法回收被循环引用的对象。
- 可达性分析：从一个根对象(GC Root)开始向下搜寻，可以认为搜寻到的所有有强引用的对象都是活跃对象，所有找不到的对象都是无用对象，无用对象可能会被即刻回收，也可能进行其他操作（比如执行对象的finalize()方法）
  这里还会引出一点问题：关于强引用，软引用，弱引用和虚引用的分别处理，具体可以看

强制垃圾回收：
程序只能控制一个对象不被任何引用变量引用，绝对不能控制它的回收。
System.gc();
Runntime.getTuntime().gc();
上面两个方法会建议系统进行垃圾回收，但是系统也有可能不进行回收。
对象的复活可以通过 finalize()方法来实现，

### android ButterKnife 依赖

​	1，如果项目只有一个 主module ，则依赖添加如下：

​		在module 的build.gradle 中添加如下

```java
api 'com.jakewharton:butterknife:8.4.0'
annotationProcessor 'com.jakewharton:butterknife-compiler:8.4.0'
```

​		在项目的 build.gradle 中添加:

```java
dependencies {
    //noinspection GradleDependency
    classpath 'com.android.tools.build:gradle:3.2.0'
     //ButterKnife 依赖
    classpath 'com.jakewharton:butterknife-gradle-plugin:8.4.0'
}
```

​	2，如果在library中使用，则需要给library的 build.gradle 中添加如下:

```java
apply plugin: 'com.android.library'
    
api 'com.jakewharton:butterknife:8.4.0'
    //noinspection GradleDependency
annotationProcessor 'com.jakewharton:butterknife-compiler:8.4.0'
```

​	在项目的 build.gradle 中添加:

```java
dependencies {
    //noinspection GradleDependency
    classpath 'com.android.tools.build:gradle:3.2.0'
     //ButterKnife 依赖
    classpath 'com.jakewharton:butterknife-gradle-plugin:8.4.0'
}
```

使用注意：

​	第一步为 绑定ButterKnife，

​	如果是一个 主module 中使用，则可以直接使用R来调用资源文件，但是如果在 library 中使用，则需要使用R2 来调用资源文件.

### 设置一个单选对话框：

```java
private String[] mGenders = new String[]{"男","女","保密"};
getGenderDialog(new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        final AppCompatTextView textView = view.findViewById(R.id.tv_arrow_value);
                        textView.setText(mGenders[which]);
                    }
                });
 //设置一个单选对话框
 private void getGenderDialog(DialogInterface.OnClickListener listener){
        final AlertDialog.Builder builder = new AlertDialog.Builder(DELEGATE.getContext());
        builder.setSingleChoiceItems(mGenders,0,listener);
        builder.show();
    }
```

# 19/5-9

###  	类加载过程

​	类加载的过程分为三个部分： 

​	1，加载 类加载是将.class 文件中的二进制数据读入内存中，将其放在运行时数据区的方法区内，然后在堆内存中创建一个对象，又来封装类在方法区内的数据接口。类加载的最终产品是为与堆中的Class 对象。

​	 2，类的连接 类加载完成后，就会进入连接阶段，连接阶段负责把类的二进制数据合并到jre中，可分为三个阶段 

​		1，验证。

​		 2，准备。

​		 3，解析。

​	 3，类的初始化 在类的初始化阶段，虚拟机负责对类进行初始化，主要是对类变量进行初始化。JVM初始化一个类包含如下几个步骤 

​		1,假如这个类没有被加载和连接，则程序加载并连接该类。

​		2,假如该类的直接父类还没有被初始化，则先初始化其直接父类。 

​		3,假如类中有初始化语句，则系统一次执行这些初始化语句。 

### 	谈谈如果优化ListView

​	1，在适配器中尽量少使用逻辑

​		不要在getView()中写过多的逻辑代码。

​	2，GC垃圾回收器

​		当创建了大量的对象时，GC就会频繁的运行，所以在getView() 方法中不要创建非常多的对象。假设你的 log 里		  面发现“GC has freed dome memory”频繁出现，那么程序肯定有问题了。

​		你可以检查一下：

​			1，item 布局的层级是否太深。

​			2，getView()方法是否有大量对象存在。

​			3，ListView 的布局属性。

​	3，载入图片

​		如果你的ListView 必须要从网络上下载图片，我们不要在 ListView 滑动的时候加载图片，那样会让ListView 变得卡顿，所以我们要监听ListView 的状态，在滑动的时候 停止载入图片，没有滑动在 开始载入图片。

```java
listView.setOnScrollListener(new OnScrollListener() {

            @Override
            public void onScrollStateChanged(AbsListView listView, int scrollState) {
                    //停止载入图片 
                    if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_FLING) {
                            imageLoader.stopProcessingQueue();
                    } else {
                    //開始载入图片
                            imageLoader.startProcessingQueue();
                    }
            }

            @Override
            public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
                    // TODO Auto-generated method stub

            }
    });
```

​	4,将 ListView 的 scrollingCache 和 animateCache 设置为false

​	**scrollingCache:** scrollingCache本质上是drawing cache，你能够让一个View将他自己的drawing保存在cache中（保存为一个bitmap），这样下次再显示View的时候就不用重画了，而是从cache中取出。默认情况下drawing cahce是禁用的。由于它太耗内存了，可是它确实比重画来的更加平滑。

​	而在ListView中，scrollingCache是默认开启的，我们能够手动将它关闭。

​	animateCache: ListView 默认开启了animateCache，这会消耗大量的内存，因此会频繁调用GC，我们能够手动将它关闭掉。

​	5，降低item的布局的深度

​	5，使用ViewHolder。

​    再次建议使用RecyclerView。

### 日期选择器 DatePicker 的封装

```java
public class DateDialogUtil {

    public interface IDateListener{
        void onDateChange(String date);
    }
    private String data = null;
    private IDateListener mDataListener = null;

    public void setDateListener(IDateListener listener){
        this.mDataListener = listener;
    }
    public void showDialog(final Context context){
        final LinearLayout ll = new LinearLayout(context);
        final DatePicker picker = new DatePicker(context);
        final LinearLayout.LayoutParams lp  = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT);
        picker.setLayoutParams(lp);
        picker.init(1990, 1, 1, new DatePicker.OnDateChangedListener() {
            @Override
            public void onDateChanged(DatePicker view, int year, int monthOfYear, int dayOfMonth) {
                final Calendar calendar = Calendar.getInstance();
                //设置时间
                calendar.set(year,monthOfYear,dayOfMonth);
                //日期格式化,使用此Java虚拟机实例的默认区域设置的当前值
                SimpleDateFormat format = new SimpleDateFormat("yyyy年MM月dd日",Locale.getDefault());
                data = format.format(calendar.getTime());
            }
        });
        ll.addView(picker);
        new AlertDialog.Builder(context)
                .setView(ll)
                .setPositiveButton("确定", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        if (mDataListener != null && data != null){
                            mDataListener.onDateChange(data);
                        }
                    }
                })
                .setNegativeButton("取消", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                })
                .show();
    }
}
```

```java
final DateDialogUtil dateDialogUtil = new DateDialogUtil();
dateDialogUtil.setDateListener(new DateDialogUtil.IDateListener() {
    @Override
    public void onDateChange(String date) {
        final TextView textView = view.findViewById(R.id.tv_arrow_value);
        textView.setText(date);
    }
});
```

# 19/5-10

### 	谈谈你对 Activity.runOnUiThread 的理解？

```java
 public final void runOnUiThread(Runnable action) {
        if (Thread.currentThread() != mUiThread) {
            mHandler.post(action);
        } else {
            action.run();
        }
    }
```

​	判断当前是不是 ui 线程，如果是就直接运行，否则就通过handler的post方法切换到主线程

### Android 权限的封装 

​	[权限的封装](https://blog.csdn.net/baidu_40389775/article/details/90051861)

### 注解权限：PermissionsDispatcher 的简单使用：

​	 @RuntimePermissions :这是必须使用的注解，用于标注你想要的申请权限的Activity或者Fragment，

```java
@RuntimePermissions
public abstract class PermissionCheckerDelegate extends Activity {
}
```

​	@NeedsPermission(Manifest.permission.CAMERA) ：

​	这个也是必须要使用的注解， 用于标注你需要获取权限的方法，注解括号里面有个参数，传入想要申请得权限，可以传入多个。当获得了对应的权限后就会执行这个方法。

```java
@NeedsPermission(Manifest.permission.CAMERA)
void startCamera() {
    LatteCamera.start(this);
}
```

​	@OnShowRationale(Manifest.permission.CAMERA) ：

​	这个不是必须的注解，用于标注申请权限 时需要执行的方法，传入想要申请的权限，还需要一个PermissionRequest对象，这个对象有两种方法  proceed()让权限继续请求，canncel()让请求中断。也就是说，这个方法会拦截你发出的请求，这个方法*  用于告诉你接下来申请权限是干啥的，说服用户给你权限

```java
  @OnShowRationale(Manifest.permission.CAMERA)
    void onCameraReational(PermissionRequest request) {
        showRetionaeDialog(request);
    }

    private void showRetionaeDialog(final PermissionRequest request) {
        new AlertDialog.Builder(getContext())
                .setPositiveButton("同意使用", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        request.proceed();
                    }
                })
                .setNegativeButton("拒绝使用", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        request.cancel();
                    }
                })
                .setCancelable(false)
                .setMessage("权限管理")
                .show();
    }
```

​	 @OnPermissionDenied注解：

​	这个也不是必须的注解，用于标注如果权限请求失败，  但是用户没有勾选不再询问的时候执行的方法，注解括号里面有参数，传入想要申请的权限。 也就是说，我们可以在这个方法做申请权限失败之后的处理，如像用户解释为什么要申请，或者重新申请操作等。

​	 onRequestPermissionsResult()方法

​	Rebuild 之后会生成一个辅助类，用来调用被注解的Activity的方法，所以，第一次使用的话*  注解添加完后 要Rebuild 一次。否则不能生成辅助类。

```java
用于储存已经被虚拟机加载的类信息、常量，静态变量等待
```

​	使用如下

```java
//调用该方法后就会申请权限，成功之后就会执行相应的代码
public void startCameraWithCheck() {
    PermissionCheckerDelegatePermissionsDispatcher.startCameraWithPermissionCheck(this);
}
```



### 封装一个全局的回调接口：

```java
public interface IGlobalCallback<T> {
    void executeCallBack(T args);
}
```

```java
public enum CallBackType {
    /**
     * 剪裁后的回调
     */
    ON_CROP
}
```

```java
public class CallbackManager {
    private static final WeakHashMap<Object,IGlobalCallback> CALLBACKS = new WeakHashMap<>();

    private static class Holder{
        private static final CallbackManager IINSTANCE = new CallbackManager();
    }
    public static CallbackManager getInstance(){
        return Holder.IINSTANCE;
    }

    public CallbackManager addCallback(Object tag ,IGlobalCallback callback ){
        CALLBACKS.put(tag,callback);
        return this;
    }
    public IGlobalCallback getCallBack(Object tag){
        return CALLBACKS.get(tag);
    }
}
```

//使用如下：

```java
	//实现
	CallbackManager.getInstance()
        .addCallback(CallBackType.ON_CROP, new IGlobalCallback<Uri>(){
            @Override
            public void executeCallBack(Uri args) {
                Log.e(TAG, "executeCallBack: "+args );
            }
        });

	//调用
	final IGlobalCallback<Uri> callback = CallbackManager
                            .getInstance()
                            .getCallBack(CallBackType.ON_CROP);
    if (callback != null){
            callback.executeCallBack(cropUri);
    }
```

调用手机相册，照相机，裁剪图片

​	[点击进行查看](https://blog.csdn.net/baidu_40389775/article/details/90066874)

# 19/5-11

### 	请列出几种常见的工厂模式，并说明他的用法？

​		[工厂模式](https://blog.csdn.net/baidu_40389775/article/details/88779940)

### 	问题：打开项目后文件名字都是J 开头，全部报红，xml 文件打开后乱码。解决办法：

​		经过查看，使用notepad 打开后发现一切正常，最后将项目换个位置。打开后一切正常

# 19/5-12

### 请说一下HashMap 和 HashTable 的区别？

​	1，HashMap 支持 null 键 和null值，而HashMap 在遇到null 是，会抛出 空指针异常。

​	2，我们说HashTable是同步的，HashMap不是，也就是说HashTable在多线程使用的情况下，不需要做额外的同步 

​	3， HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。 

​	4，HashTable 继承子Dictionary 类，二HashMap 继承AbstractMap 类，但是二者都实现了Map 接口

​	5， Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。 

用于储存已经被虚拟机加载的类信息、常量，静态变量等待