# 2019/11-1

### 今日总结

​		完成门店列表和门店详情的大致逻辑。后台的接口弄好了，但是没解析处理，研究了好长时间都没弄好，下班回来仔细看了一下，结果是数据不一致造成的，明天去让后台改一哈。。。

​		修改了 fragment 跳转时动态改变状态栏颜色的问题，解决如下：默认全局的状态栏颜色为透明。然后直接修改 Toolbar 的颜色，最后调用工具类中的方法让 Toolbar 位于状态栏的下面即可。

​		找到了前两天遇到的 design 包的问题，暂时无法解决。因为我电脑项目中的 design 是 goole 下面的，而公司的 design 是 support 下面的，所以造成了一些问题。如果要修改，就需要升级公司 as 的版本，暂时不能升级，最近有点忙，升级版本是大事情，要找一个好的时机来升级。

### 明日计划

​		完成门店列表和门店详情的逻辑，完成 RecyclerView 上滑刷新的功能

​		应该需要修改所有的列表页面布局，希望用到的布局是一个吧，那样还简单一点。。

​		其他的待定。。

### 补充

​		加快工作效率，努力，坚持，加油！

# 2019/11-2

### 今日总结

​		完成门店详情和门店列表，对接数据，修改 UI ，目前已经完成

​		修改了 RecyclerView 滑动时会变白的问题，那是一个动画效果，默认是开启的，关闭即可，可怜我找了好几天

​		重构，对 RecyclerView 进行封装，以前就弄好的，就是复制粘贴一下。完成了设置的布局。

### 明日计划

​		继续重构，看一下艺术探索。。

​		其他的待定。。

### 补充

​		明天周天，看到底几天起床。。。早睡

# 2019/11-3

### 今日总结

​		今天周天，起的有点晚，将封装的 dialog 上传到维护的库中

​		发现网络请求中参数的 bug，进行修改，完成个人资料界面，权限的使用

​		快 十一点了，等一下看看艺术探索

#### 明日计划

​		明天可能要请假，已经发起了，但是未通过

​		继续重构。

### 补充

​		没有补充。。。。

# 2019/11-4

​		今天请假了，办理身份证，还好办理成功了。。。顺带洗了个澡。跑了一天了，乏了，老早睡！！

# 补：2019/11-5

​			有事

# 2019/11-6

### 今日总结

​		修改了所有的列表界面，解决了数据重复得问题。

​		进行九格宫切割，未实现。。。。 升级公司的 as 版本，升级完成，但是有问题未解决

​		重构，增加调用相机，打开相册。图片裁剪报错，未解决

### 明日计划

​		赶紧解决一下 as 升级后带来的问题，尽量完成图片切割

​		找一下 图片裁剪报错的原因，完成工作内容

​		其他待定。。

### 补充

​		加快效率，学习设计模式

# 2019/12-7

### 今日总结

#### 		策略模式

​	 	总结一下：简单的理解就是将公有的方法抽象成一个接口，或者抽象类。然后让具体的业务去实现它。最后通过调用接口的方法来实现具体的业务逻辑。

​		例如：有一个界面，这个界面有一个列表，点击列表中的某一项跳转的不同的 activity。这个时候你会怎么办？

​				   难道要在 adapter 中写一个 switch 判断下标然后进行跳转吗？？ 这样就太 low 了。

​				   解决方法：策略模式

​				   定义一个接口，定义一个方法，用来实现跳转。然后让列表的 item 全部实现这个接口，并且实现相应的跳转逻辑，最后通过在 adapter 中获取到item。向上转型为接口。调用跳转方法即可。 其实我们会把最后一步进行封装，封装为一个类，在类中 定义接口的引用，然后通过一个方法进行赋值，最后直接跳转。最后的这个类就是环境角色。这样可以进行解耦，看起来比较清爽。。

​		好处：

​			1，提高代码的的复用性，如果别的类具有相同的业务，可以直接继承或者实现该策略

​			2，对代码进行解耦，结构更加清晰，避免使用大量的 switch ，if else 等。

​			3，扩展性比较强，耦合降低

​		缺点：

​			1，可能会有很多的策略类和实现类，用户需要知道所有的类

​			2，增加了系统的开销

------

​		学习策略模式，并简单的应用到项目中。以后会继续进行完善

​		修改了 as 版本升级后出现的错误

​		自定义一个图片的裁剪 View，这个 View 里面图片的移动，缩放，旋转等都是从网上找的。我对他进行了九格宫的绘制，图片的裁剪，将View转为 bitmap 等。

### 明日计划

​		了解一下图片的压缩，bitmap 压缩方式

​		感觉目前 mvp 还是有一些不足，冥想一下，找不足

​		继续看设计模式，完成面试题，其他的待定

### 补充

​		努力，坚持，加油！！！

# 2019/11-8

### 今日总结

​		今天有点偷懒。。 学习了一下 bitmap 的用法，设计模式的 6 大原则，**单一原则**：对于一个类而言，只有一个可以引起他变化的原因，简单点说就是一个类只干一件事。**开放封闭原则**：对于一个模块或者一个功能来说，他必须符合可扩展性，同时不能进行修改。**里氏替换原则**：所有引用基类（父类）的地方必须能透明的使用其子类的对象，这个我看着有点懵。**依赖倒置原则**：抽象不应该依赖于细节，细节应该依赖于抽象，依赖倒置原则要求我们在代码中传递参数或者存在关联行为时，尽量使用接口或者抽象来进行变量的声明，方法的声明，参数类型的声明，返回值的声明等，不应该用具体的类来做这些事。**迪米特原则**：一个类应该尽量不与其他的类发生关系，需要减少对象之间的交互，如果一个对象要调用另外一个对象的方法，则可以通过第三者转发这个调用。**接口隔离原则**：一个接口不能承担太重的责任，应该将责任进行划分，一个接口只有一种责任，只干该干的是，不该干的事不干。

​		完成了商品界面和逻辑的处理，碰到了一个问题，使用 RecyclerView 在刷新的时候闪退了，最后查资料发现是底层的问题，用了这么长时间都没有发现这个问题。。。

​		看了一点 kotile，真的是太简洁了，有点上头

### 明日计划

​		找了一下热修复的视频，明天看一哈。。。

​		其他的待定。

### 补充

​		早睡早起！！

# 补：2019/11-9

​		最近在看热修复，看到第一节，下面回顾一下：

​		**什么是 class 文件**：class 文件指的是能够被 java识别，并且可以加载执行文件。class 文件是 .java 文件通过编译后产生的一个文件，不止是 java 文件可以生成，还有 py 等都可以生成 class 文件。**如何生成 class 文件**：同 IDE run 或者命令行都可以生成。**class 文件的作用**：他包含了java类中的所有信息，例如 变量、方法、常量、接口，等，还有一些是 jvm 帮我们添加进去的，例如 this、super 等。**class 文件的结构**：本质是一个八位字节的二进制流，内部结构非常紧密，没有空隙。其结构是结构体，内部主要有，加密字段，两个 version 最小能够被那个版本的 jdk 加载，还有当前 class 是那个版本生成的，常量池数量，常量池，常量池，接口数量，接口信息，方法数量，方法信息，作用域等等。常量池中有一个 u1 类型的无符号数表示，通过这个 u1 我们可以知道他内部保存的啥啥数据。

​	**什么是 dex 文件**：能够被 DVM 识别并且加载的文件。**如何生成 dex 文件**：dex 文件是 class 的进化版，生成dex，必须要有 class 文件，通过 adb 命令可以生成 dex 文件，注意 dex 文件不能直接运行在电脑上，必须发布的模拟器或者手机上才可以运行。**dex 文件的作用**：内部包含了整个工程中所有的 class 文件信息，注意，这里是整个工程。**dex文件结构**：他同样是 8位字节的二进制文件流，dex 文件分为三个部分，分别是 头文件，索引和数据区，头文件中主要是dex文件中的一些信息，索引则包含的比较多，如 方法索引，类型索引，字段缩影，方法原型索引，字符串索引，还有一个 map ，他里面的内容是对头文件的校验，最后就是数据区了，索引对应的值即为数据区。

​	两者之间的区别

​	class 内存占用较大，不适合移动端，采用了堆栈的加载模式，速度较慢，文件的 IO 操作过多，每次加载时都要去寻找和加载。

​	dex 将信息划分成了 三个区域，这三个区域中包含了工程中所有的信息，所以在类越来越多的时候他的优势就提现出来了，并且有些区域是可以复用的。减少了 dex 文件的大小。

​	本质上来说他们是一样的，dex 是由 class 演化而来，他减少了 class 的沉余，并且进行了整合。

# 2019/11-10

### 今日总结

​		今天周天，昨天晚上去别人家了，早上回来的有点晚。。。今天主要集成了高德的 SDK ，目前只使用了定位，

​		完成了首页的布局和一些逻辑。复习了一些昨天看得 class 和 dex

​		想改一下 mvp 的 p 层接口，但是苦于没有思路，最后询问了一番，发现都是这样写的。就先这样吧！

### 明日计划

​		继续热修复的第二节。

​		完成工作内容，看一下设计模式，好久没做过面试题了，明天看一下

​		其他的待定。。

### 补充

​		没有补充。。。。	

# 2019/11-11

### 今日总结

​		加深理解了 dex 的构造，使用 010 Editer 查看 dex 的文件结构，在16进制中查找某些字符串的具体位置等

​		深入了解 JVM 和 DVM ，总结如下：

​			jvm 的内存结构：**方法区**：用来保存类信息，常量、静态变量等信息。**java栈**：又栈贞组成，每一个方法对应着一个栈贞，栈贞中包含了方法所创建的局部对象，变量等，在方法开始执行时，所对应的的栈贞就会被压如 java 栈中，方法结束后则出栈。**本地方法栈**：和 java 栈基本类似，只不过是为 naive 方法服务的，**堆区**：每 new 一个新的对象时就会在堆中开辟一个新的空间，堆区中有新生旦和老生旦等。

​		类加载，java 中有四个加载类的 ClassLoader ，前两个名字忘了，他们加载的是 jdk 中的类，第三个则是 AppClassLoader ，他加载的是应用程序中的类。最后一个是 CustomClassLoader，这个是我们可以进行自定义的类加载

​		类加载过程：**加载**：从文件中获取 class 并加载到 jvm 的内存中，**验证**：对加载的类进行验证，是否符合 JVM 的规范。**准备**：分配一个结构来保存类的相关信息。**解析**：将常量池中的符号引用改为直接引用。初始化：对类进行初始化静态方法赋值等。

​		垃圾收集算法：1，引用计数法，被引用+1，取消引用-1，缺点，两个对象相互引用且没有别的对象引用这两个对象则会造成这两个对象无法回收，2，可达性算法，从GC Root 开始遍历寻找引用的节点，知道找不到引用的节点。到最后没有找到的则为垃圾对象。

​		垃圾清理算法：1，标记清除法，从 根集合进行遍历，遍历不到的则会被标记，最后被清除。缺点，会造成内存碎片2，复制算法，将可达的进行复制，然后把原来的所有对象进行回收。缺点，需要一个交换空间，3，标记整理算法，从跟集合中扫描不可达的对象进行标记，最后在整理的过程中回收标记的对象

​		Dalvik 和 JVM 的区别

​		1，一个加载 class，一个加载 dex

​		2，Dalvik 可以同时存在多个 DVM ，而且两者类加载区别较大

​		3，Dalvik 基于寄存器，JVM 基于栈

​		Dalvik 和 ART 的区别

​		1，DVM 使用 JIT 将字节码转换为机器码，效率较慢

​		2，ART 则会在程序安装的过程中将字节码转为本地机器码，这种执行很快

​		3，ART 会占用更多的安装时间和存储空间

### 明日计划

​		学习热修复的第三章，应该是到了 ClassLoader，这块需要好好学一下

​		其他的待定

### 补充

​		双十一，看一哈没有有能买衣服 ，，，