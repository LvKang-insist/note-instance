### Activity 异常情况下的生命周期

- 资源相关的系统配置发生改变导致 activity 被杀死并重新创建

  如横竖屏切换时：activity 被杀死，即调用 onPause，onStop，onDestroy，同时调用 onSaveInstanceState 保存 activity 的状态，这个方法在 activity 异常终止时调用。重新创建时，系统会调用 onRestoreInstanceState 和 onCreate 方法，通过这两个可以判断 activity 是否被重建

  如果不想 activity 屏幕旋转重建，可以设置 configChange=“orientation|screenSize”

- 资源不足导致低优先级的 activity 被杀死

  1，前台 activity，与用户交互的 activity，优先级最高

  2，可见非前台，比如出现了一个弹窗，导致 activity 可见但不能进行交互

  3，后台activity，已经被暂停，执行了 onStop 方法，优先级最低

### 如何判断图片需要放在那些文件夹中

​	ldpi：240 X 320

​	mdpi：320 X 480

​	hdpi：480 X 800

​	xhdpi：960 X 720

​	xxhdpi：1280 X 720

### Integer 和 int 之间的区别

- Integer 是 int 的包装类，必须实例化之后才可以使用，而 int 则不需要实例化
- int 是 java 中一种基本的数据类型，
- integer 的对象时引用，当 new 一个 Integer 时，实际上是生成的一个指针指向此对象。而int 则是直接存储数据值
- Integer 默认值为 null，int 默认值为 0

### String 转换 integer 的方式以原理

​		

### Activity 切换到 后台，在切换到前台的生命周期

A调用： onCreate  -> onStart -> onResume A 可见，接着 A 跳转 B 时， 接着调用 onPause。

B调用： onCreate ->onStart ->onResume B 可见，这时 A 调用 onStop，当 A 回到前台时：B调用 onPause，然后 A 调用 onReStart -> onStart -> onResume。然后b 调用 onStop -> onDestory 。

### 弹出 Dialog 时按 Home 键 Activity 的生命周期

​	弹出dialog：onCreate() -> onStart() -> onResume

​	按下Home：onCreate() -> onStart() -> onResume -> onPause() -> onStop()  	

​	为啥弹出 dialog 时没有执行 onPause 方法？

​		我们弹出的 AlertDialog 对话框实际上是 Activity 的一个组件，此时的activity 并不是不可见，而是被一个布满屏幕的组件覆盖掉了，所以没办法进行操作。当点击了 Home 时 activity 才进入了后台。

###  对 BroadcastReceiver 的了解？ 

​	广播接收者，需要在清单文件中进行注册，还需要声明那种类型的广播能被广播接收器接收到。

​	发送广播的方式：

​		1，标准广播：广播发出后，符合要求的广播几乎会在同一时间接收到广播

​		2，有序广播：广播发出后，同一时刻只能有一个广播接收到。可以选择继续传递，也可以拦截此广播。优先级高的会先接收到广播。

​	本地广播

​		本地广播是一种只能被本程序广播接收器所接收的广播

### 动态广播和静态广播有什么不同

- 动态的比静态安全
- 静态在 App 启动时候就初始化了，动态则在代码中初始化
- 静态需要在 清单文件中配置，动态不需要
- 静态广播的生存期比动态长很多
- 动态广播优先级比静态的高

### Android 项目构建过程

​	1，AAPT(Android Asset PackagingTool) 工具会打包应用中的资源文件，如 AndroidManifest.xml ，layout 中的布局等，并将xml 文件编译为 二进制形式，当然 assets 中的文件不会被编译。图片及 raw 文件资源会保持原来的形态，raw 中的资源会生出资源 id，AAPT 编译完成之后会生成 R.java 文件。

​	2，AIDL 工具会将所有的 aidl 接口转化为 java 接口

​	3，所有的 java 代码，包括 aidl 和 R.java 都会被 java 编译器编译成 .class 文件，

​	4，Dex 工具会将上述产生的 .class 文件以及第三方库及其他的 .class 文件编译成 .dex文件(dex 文件是Dalvik 虚拟机可以执行的格式)，dex 文件最终被打包进 APK文件。

​	5，ApkBuilder 工具会将编译过的资源文件 及 未编译过的(如 图片等) 以及 .dex 文件 打包成 APK 文件

​	6，生成 apk 文件后，需要对齐签名才可安装到设备，平时测试会使用 debug keystore，当正式版发布时，必须使用 release 版的 keystore 进行签名。

​	7，如果对 APK 正式签名，还需要使用 zipalign 工具对 APK 进行对齐操作，这样的好处是应用运行时会提高速度，但是会相应增加内存开销。

### ArrayList 和 LinedList 的区别

​	ArrayList：底层采用数组的方式，查询快，增删慢，允许 null 元素，线程是不安全的，从 JDK 1.8 开始 默认初始容量为 10

​	LinkedList：底层采用链表，可以将元素插入到首部或者尾部，线程是不安全的，增删快，查询较慢。

### 静态代理和动态代理

​	静态代理：主要有 接口，被代理类，代理类 。被代理类 和 代理类都实现 接口。最后给 代理类传入 被代理类的对象，然后 就可以通过 代理类去调用 被代理类的 方法，并且可在代理类中完成一些额外的操作。这样的好处就是：在 一个类不能被直接修改 或者是 不想直接创建他的对象时，可以 new 一个代理类，通过这个代理 进行 控制，并且很容易添加一些新的方法。

​	动态代理：主要有 接口，被代理类。通过 Proxy.newProxyInstance 方法 可以生成一个方法，在这个方法中可以直接调用被代理类的方法，并可以添加一些额外的操作。如下所示：

```java
// 接口
interface Subject {
    void sub();
}

// 被代理类
class RctSub implements Subject {
    @Override
    public void sub() {
        System.out.println("rct");
    }
}


private static RctSub rct;
public static void main(String[] args) {
        rct = new RctSub();
        //创建动态代理
        Subject subject = create(Subject.class);
        //调用 sub 会执行下面的 invoke 方法，
        subject.sub();
}

public static <T> T create(final Class<T> cls) {
        return (T) Proxy.newProxyInstance(cls.getClassLoader(), new Class[]{cls}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                //调用被代理类的方法，
                return method.invoke(rct, args);
            }
        });
    }
```

好处是：在程序运行期间，会自动生成代理类，代理类逻辑 和 业务逻辑 进行解耦。

### Bundle 传递数据为什么不支持对象，Serializable 和 Parcelable 的区别

因为 Bundler 只支持基本数据类型的传输，所以在传递对象时，需要将对象进行序列化，被序列化的对象可以被保存在本地文件中，也可以在网络，IPC 直接进行传输。

Serializable ：java 自带的序列化，实现该接口可以实现对象的序列化，被序列化的对象可直接使用 IO 流进行读写等操作。如果被序列化的对象中有引用类型，那么这个引用类型也必须是可序列化的，否则将无法被序列化

Parcelable ：android 的序列化，本质是将对象分解为基本数据类型，分解之后的每一个部分都是 Bundle 所支持的类型。

区别：

​			Serializable  将对象转换为可存储的状态，使用非常简单，但是效率很低，在序列化的过程中会有大量的 IO 操作，适合将对象保存在本地，或者通过网络传输。

​		    Parcelable  将对象分解为基本数据类型，使用比较复杂，但是效率高，主要用于内存中的序列化。

### JVM 内存模型 和 内存区域

- 内存模型：

  java 内存模型规定了所有的变量都是存储在主内存中，每个线程都有自己的工作内存，**线程的工作内存中保存了该线程用到的变量的主内存副本拷贝**，也就是说每个子线程中都有用到的主内存中的变量都是从主内存拷贝的副本。线程对变量的所有操作都必须在工作内存中，不能直接读写主内存中的变量。不同的线程直接也无法方法对方工作内存中的变量。线程之间的值传递需要用主内存来完成。

- 内存区域：

   ![img](19_10.assets/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31312f30352f356264666365353738633035352e6a7067.jpg) 

  程序计数器：

  他是一个比较小的控件，可以看作是当前线程所执行的字节码的行号指示器。如果线程执行的是 java 方法，这个计数器记录的就是正在执行的虚拟机字节码指令的地址；如果是 Native方法，他则为空。此内存区域是唯一一个没人规定任何 OOM 的区域

  虚拟机栈：

  虚拟机栈描述的是 java 方法执行的内存模型：每个方法在执行的同时会创建一个栈用于存储局部变量表，操作数栈，方法出口等信息。每一个方法从调用到执行完的过程就对应着一个栈在虚拟机中入栈到出栈的过程。

  本地方法栈：

  和虚拟机栈类似，只不过是虚拟机栈Wie java 方法服务，而本地方法栈为虚拟机执行 Native 方法服务。

  堆：

  用来存放对象的实例。

  方法区：

  用于储存已经被虚拟机加载的类信息、常量，静态变量等待

  