### Activity 异常情况下的生命周期

- 资源相关的系统配置发生改变导致 activity 被杀死并重新创建

  如横竖屏切换时：activity 被杀死，即调用 onPause，onStop，onDestroy，同时调用 onSaveInstanceState 保存 activity 的状态，这个方法在 activity 异常终止时调用。重新创建时，系统会调用 onRestoreInstanceState 和 onCreate 方法，通过这两个可以判断 activity 是否被重建

  如果不想 activity 屏幕旋转重建，可以设置 configChange=“orientation|screenSize”

- 资源不足导致低优先级的 activity 被杀死

  1，前台 activity，与用户交互的 activity，优先级最高

  2，可见非前台，比如出现了一个弹窗，导致 activity 可见但不能进行交互

  3，后台activity，已经被暂停，执行了 onStop 方法，优先级最低

### 如何判断图片需要放在那些文件夹中

​	ldpi：240 X 320

​	mdpi：320 X 480

​	hdpi：480 X 800

​	xhdpi：960 X 720

​	xxhdpi：1280 X 720

### Integer 和 int 之间的区别

- Integer 是 int 的包装类，必须实例化之后才可以使用，而 int 则不需要实例化
- int 是 java 中一种基本的数据类型，
- integer 的对象时引用，当 new 一个 Integer 时，实际上是生成的一个指针指向此对象。而int 则是直接存储数据值
- Integer 默认值为 null，int 默认值为 0

### String 转换 integer 的方式以原理

​		

### Activity 切换到 后台，在切换到前台的生命周期

A调用： onCreate  -> onStart -> onResume A 可见，接着 A 跳转 B 时， 接着调用 onPause。

B调用： onCreate ->onStart ->onResume B 可见，这时 A 调用 onStop，当 A 回到前台时：B调用 onPause，然后 A 调用 onReStart -> onStart -> onResume。然后b 调用 onStop -> onDestory 。

### 弹出 Dialog 时按 Home 键 Activity 的生命周期

​	弹出dialog：onCreate() -> onStart() -> onResume

​	按下Home：onCreate() -> onStart() -> onResume -> onPause() -> onStop()  	

​	为啥弹出 dialog 时没有执行 onPause 方法？

​		我们弹出的 AlertDialog 对话框实际上是 Activity 的一个组件，此时的activity 并不是不可见，而是被一个布满屏幕的组件覆盖掉了，所以没办法进行操作。当点击了 Home 时 activity 才进入了后台。

###  对 BroadcastReceiver 的了解？ 

​	广播接收者，需要在清单文件中进行注册，还需要声明那种类型的广播能被广播接收器接收到。

​	发送广播的方式：

​		1，标准广播：广播发出后，符合要求的广播几乎会在同一时间接收到广播

​		2，有序广播：广播发出后，同一时刻只能有一个广播接收到。可以选择继续传递，也可以拦截此广播。优先级高的会先接收到广播。

​	本地广播

​		本地广播是一种只能被本程序广播接收器所接收的广播

### 动态广播和静态广播有什么不同

- 动态的比静态安全
- 静态在 App 启动时候就初始化了，动态则在代码中初始化
- 静态需要在 清单文件中配置，动态不需要
- 静态广播的生存期比动态长很多
- 动态广播优先级比静态的高

### Android 项目构建过程

​	1，AAPT(Android Asset PackagingTool) 工具会打包应用中的资源文件，如 AndroidManifest.xml ，layout 中的布局等，并将xml 文件编译为 二进制形式，当然 assets 中的文件不会被编译。图片及 raw 文件资源会保持原来的形态，raw 中的资源会生出资源 id，AAPT 编译完成之后会生成 R.java 文件。

​	2，AIDL 工具会将所有的 aidl 接口转化为 java 接口

​	3，所有的 java 代码，包括 aidl 和 R.java 都会被 java 编译器编译成 .class 文件，

​	4，Dex 工具会将上述产生的 .class 文件以及第三方库及其他的 .class 文件编译成 .dex文件(dex 文件是Dalvik 虚拟机可以执行的格式)，dex 文件最终被打包进 APK文件。

​	5，ApkBuilder 工具会将编译过的资源文件 及 未编译过的(如 图片等) 以及 .dex 文件 打包成 APK 文件

​	6，生成 apk 文件后，需要对齐签名才可安装到设备，平时测试会使用 debug keystore，当正式版发布时，必须使用 release 版的 keystore 进行签名。

​	7，如果对 APK 正式签名，还需要使用 zipalign 工具对 APK 进行对齐操作，这样的好处是应用运行时会提高速度，但是会相应增加内存开销。

