### Activity 异常情况下的生命周期

- 资源相关的系统配置发生改变导致 activity 被杀死并重新创建

  如横竖屏切换时：activity 被杀死，即调用 onPause，onStop，onDestroy，同时调用 onSaveInstanceState 保存 activity 的状态，这个方法在 activity 异常终止时调用。重新创建时，系统会调用 onRestoreInstanceState 和 onCreate 方法，通过这两个可以判断 activity 是否被重建

  如果不想 activity 屏幕旋转重建，可以设置 configChange=“orientation|screenSize”

- 资源不足导致低优先级的 activity 被杀死

  1，前台 activity，与用户交互的 activity，优先级最高

  2，可见非前台，比如出现了一个弹窗，导致 activity 可见但不能进行交互

  3，后台activity，已经被暂停，执行了 onStop 方法，优先级最低

### 如何判断图片需要放在那些文件夹中

​	ldpi：240 X 320

​	mdpi：320 X 480

​	hdpi：480 X 800

​	xhdpi：960 X 720

​	xxhdpi：1280 X 720

### Integer 和 int 之间的区别

- Integer 是 int 的包装类，必须实例化之后才可以使用，而 int 则不需要实例化
- int 是 java 中一种基本的数据类型，
- integer 的对象时引用，当 new 一个 Integer 时，实际上是生成的一个指针指向此对象。而int 则是直接存储数据值
- Integer 默认值为 null，int 默认值为 0

### String 转换 integer 的方式以原理

​		

### Activity 切换到 后台，在切换到前台的生命周期

A调用： onCreate  -> onStart -> onResume A 可见，接着 A 跳转 B 时， 接着调用 onPause。

B调用： onCreate ->onStart ->onResume B 可见，这时 A 调用 onStop，当 A 回到前台时：B调用 onPause，然后 A 调用 onReStart -> onStart -> onResume。然后b 调用 onStop -> onDestory 。

### 弹出 Dialog 时按 Home 键 Activity 的生命周期

​	弹出dialog：onCreate() -> onStart() -> onResume

​	按下Home：onCreate() -> onStart() -> onResume -> onPause() -> onStop()  	

​	为啥弹出 dialog 时没有执行 onPause 方法？

​		我们弹出的 AlertDialog 对话框实际上是 Activity 的一个组件，此时的activity 并不是不可见，而是被一个布满屏幕的组件覆盖掉了，所以没办法进行操作。当点击了 Home 时 activity 才进入了后台。

###  对 BroadcastReceiver 的了解？ 

​	广播接收者，需要在清单文件中进行注册，还需要声明那种类型的广播能被广播接收器接收到。

​	发送广播的方式：

​		1，标准广播：广播发出后，符合要求的广播几乎会在同一时间接收到广播

​		2，有序广播：广播发出后，同一时刻只能有一个广播接收到。可以选择继续传递，也可以拦截此广播。优先级高的会先接收到广播。

​	本地广播

​		本地广播是一种只能被本程序广播接收器所接收的广播

### 动态广播和静态广播有什么不同

- 动态的比静态安全
- 静态在 App 启动时候就初始化了，动态则在代码中初始化
- 静态需要在 清单文件中配置，动态不需要
- 静态广播的生存期比动态长很多
- 动态广播优先级比静态的高

### Android 项目构建过程

​	1，AAPT(Android Asset PackagingTool) 工具会打包应用中的资源文件，如 AndroidManifest.xml ，layout 中的布局等，并将xml 文件编译为 二进制形式，当然 assets 中的文件不会被编译。图片及 raw 文件资源会保持原来的形态，raw 中的资源会生出资源 id，AAPT 编译完成之后会生成 R.java 文件。

​	2，AIDL 工具会将所有的 aidl 接口转化为 java 接口

​	3，所有的 java 代码，包括 aidl 和 R.java 都会被 java 编译器编译成 .class 文件，

​	4，Dex 工具会将上述产生的 .class 文件以及第三方库及其他的 .class 文件编译成 .dex文件(dex 文件是Dalvik 虚拟机可以执行的格式)，dex 文件最终被打包进 APK文件。

​	5，ApkBuilder 工具会将编译过的资源文件 及 未编译过的(如 图片等) 以及 .dex 文件 打包成 APK 文件

​	6，生成 apk 文件后，需要对齐签名才可安装到设备，平时测试会使用 debug keystore，当正式版发布时，必须使用 release 版的 keystore 进行签名。

​	7，如果对 APK 正式签名，还需要使用 zipalign 工具对 APK 进行对齐操作，这样的好处是应用运行时会提高速度，但是会相应增加内存开销。

### ArrayList 和 LinedList 的区别

​	ArrayList：底层采用数组的方式，查询快，增删慢，允许 null 元素，线程是不安全的，从 JDK 1.8 开始 默认初始容量为 10

​	LinkedList：底层采用链表，可以将元素插入到首部或者尾部，线程是不安全的，增删快，查询较慢。

### 静态代理和动态代理

​	静态代理：主要有 接口，被代理类，代理类 。被代理类 和 代理类都实现 接口。最后给 代理类传入 被代理类的对象，然后 就可以通过 代理类去调用 被代理类的 方法，并且可在代理类中完成一些额外的操作。这样的好处就是：在 一个类不能被直接修改 或者是 不想直接创建他的对象时，可以 new 一个代理类，通过这个代理 进行 控制，并且很容易添加一些新的方法。

​	动态代理：主要有 接口，被代理类。通过 Proxy.newProxyInstance 方法 可以生成一个方法，在这个方法中可以直接调用被代理类的方法，并可以添加一些额外的操作。如下所示：

```java
// 接口
interface Subject {
    void sub();
}

// 被代理类
class RctSub implements Subject {
    @Override
    public void sub() {
        System.out.println("rct");
    }
}


private static RctSub rct;
public static void main(String[] args) {
        rct = new RctSub();
        //创建动态代理
        Subject subject = create(Subject.class);
        //调用 sub 会执行下面的 invoke 方法，
        subject.sub();
}

public static <T> T create(final Class<T> cls) {
        return (T) Proxy.newProxyInstance(cls.getClassLoader(), new Class[]{cls}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                //调用被代理类的方法，
                return method.invoke(rct, args);
            }
        });
    }
```

好处是：在程序运行期间，会自动生成代理类，代理类逻辑 和 业务逻辑 进行解耦。