# 19/9-9

​	上班的一周后，今天正式开始添加功能了，是一个二手车鉴定，总的来说不是太复杂，但是因为项目不太熟悉的缘故，所以没有做出来。明天开始，每天在 Type 打卡，每日一个面试题，每天都需要掌握新知识。就这样了。

# 19/9-10

#### 什么是悲观锁和乐观锁？ 

锁是为了避免自己在修改资源的时候，别人同时在修改，导致同一时间产生两份修改，不知道如何处理的情况而设置的独占资源，避免多个操作同时处理同一资源的技术。

乐观锁：默认为，某个线程在自己处理共享资源的时候，不会出现同一时刻来修改此资源的前提，只在处理完毕，最后写入内存的时候，检测是否此资源在之前未被修改。类似于读写锁的读锁就是乐观锁。

悲观锁：默认为，某个线程在自己处理共享资源的时候，一定会出现同一时刻来修改此资源，所以刚拿到这个资源就直接加锁，不让其他线程来操作，加锁在逻辑处理之前。类似，synchronized关键字，条件锁，数据库的行锁，表锁等就是悲观锁。

#### 日志

工作 上完成商品鉴定页面的ui，使用 RecyclerView 的第三方适配器，实现了 多级列表。

修改mvp 框架，碰到一个问题，在使用 navigation 时发现 好像不能从当前碎片跳转到子碎片。暂时没有找到解决办法。想象是否可以在创建一个 xml 文件管理子碎片

# 19/9-11

#### java 中 IO 流分为几种?BIO,NIO,AIO 有什么区别?

​	Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的.

​	BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。

BIO是一个连接一个线程。
NIO是一个请求一个线程。
AIO是一个有效请求一个线程。

- BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
- NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
- AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

#### 日志

工作上完成了二手鉴定店铺的详情界面，并进行了数据的对接，完成了提交订单界面的构建和数据。明天实现提交订单的功能。

在使用 Navigation 时发现他的局限性有点大，比如无法添加子碎片，在子碎片中无法切换父碎片等。查了资料，没找到处理方法，不知道是我没查到还是没有。考虑是否需要 取消使用 Navigation。

睡觉 。。。。。。

# 19/9-22

​	中间有点时间耽搁了。没写，从今天开始恢复正常

####  	首先写一下工作时apk的发布流程


	1，获取上一个版本
	2，修改接口地址， 正式版的 url为：
			 public static final String BASE_URL = "https://www.4sno1.com/JSCM/";//1.2.4
			 public static final String BASE_URL_HTML = "https://www.4sno1.com/";
	
			 pd 是 打包测试用的
			 public static final String BASE_URL = "https://www.nuli100.com/JSCM_PD/" //1.5.4	
			 public static final String BASE_URL_HTML = "https://www.nuli100.com/	
	
			 下面这个是公司内部使用的
			 public static final String BASE_URL = "https://www.nuli100.com/JSCM/";//1.3.1
			 public static final String BASE_URL_HTML = "https://www.nuli100.com/"
	
			 最后就是测试用的
			 public static final String BASE_URL = "http://192.168.199.196/JSCM/";
	    		 public static final String BASE_URL_HTML = "http://192.168.199.196";
	3，修改版本
		
		首先确定要发布的是否为正式版，如果是正式版,首先确定上一个版本号，然后将versionName进行 +1，versionCode 也 +1. 如果是需要打包测试，则使用上面的pd url。然后将 versionName 进行+1，versionCode 不需要动。versionCode 只是在发布正式版的时候需要+1.
	
	4，进行加固
		如果是打包进行测试的则不需要进行加固。
		如果是正式版，则需要进行加固。目前需要使用的加固为 乐加固 和 360加固。注意乐加固会生成俩个apk，我们需要的是哪个最后面为 signed 的apk，在加固的时候一定要注意签名，因为 有两个app 的签名文件，如果选择错了，会导致 app 不能进行升级等一系列的问题。所以在进行加固的时候 一定要让签名文件和app 相对应。
	5，发布
		直接发给后端。
# 19/9-23

#### 	正确判断当前的 fragment 是显示还是隐藏

​	1、当Fragment配合ViewPager使用时，使用setUserVisibleHint()判断Fragment是显示还是隐藏。  
​	2、当Fragment配合FragmentTransition使用时，使用onHiddenChanged()来判断Fragment是显示还是隐藏，但是第一次显示要在onResume()里判断。

#### 修改 TabLayout 的下划线宽度

​	修改下划线的宽度没有给定的api，但是可以通过反射去修改，如下所示：

```java
// 设置TabLayout下划线长度
	public static void setIndicator(TabLayout tabs, int leftDip, int rightDip) {
		Class<?> tabLayout = tabs.getClass();
		Field tabStrip = null;
		try {
			tabStrip = tabLayout.getDeclaredField("mTabStrip");
		} catch (NoSuchFieldException e) {
			e.printStackTrace();
		}

		tabStrip.setAccessible(true);
		LinearLayout llTab = null;
		try {
			llTab = (LinearLayout) tabStrip.get(tabs);
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}

		int left = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, leftDip, Resources.getSystem().getDisplayMetrics());
		int right = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, rightDip, Resources.getSystem().getDisplayMetrics());

		for (int i = 0; i < llTab.getChildCount(); i++) {
			View child = llTab.getChildAt(i);
			child.setPadding(0, 0, 0, 0);
			LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT, 1);
			params.leftMargin = left;
			params.rightMargin = right;
			child.setLayoutParams(params);
			child.invalidate();
		}

	}
```

使用的时候直接调用即可。

#### Intent 传输的数据有大小限制吗？如何解决

​	Intent 传输数据的消息受 Binder 限制，上限 1M ，不过这个 1M 并不是安全的上限，Binder可能在处理别的工作，安全上限是多少在不同的机型上也不一样

​	传 512K 以下的数据可以正常传递

​	传512 -- 1024K 的数据可能会出错，闪退

​	传1M 以上的数据会报错：TransactionTooLargeException

​	考虑到Intent 还要包括启动 Activity 等信息，实际传输大小可略小于 512K

​	解决办法

​	1，减少数据传输量

​	2，Intent 通过绑定一个 Bundle 传输，这个可以超过 1M，不过也不能过大

​	3，通过内存共享，使用静态变量或者使用 EventBus 等类似的通信工具

​	4,通过文件共享

# 2019/9-24

#### 为什么要将 String 设计为不可变

​	1，字符串常量池的需要

​			当创建一个 String 对象时，如果此字符串已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象

​			如果允许改变，那么将导致各种逻辑错误，比如改变一个对象将会影响另一个独立对象，严格来说，这种常量池的思想是一种优化手段

​	2，允许String对象缓存 HashCode

​			java 中 String 对象的哈希码会被频繁的使用，比如在 hashMap中。字符串的不变形保证了hash码的唯一性，因此可以放放心的进行缓存。这也是一种优化手段，意味着不必没说都计算新的哈希码。在 String 类中有 private int hash 来缓存hashcode

​	3，安全性

​			String 被许多的类来当做参数，如 网络url，文件路径path 等等，如果String 不是固定的，将会引起各种安全隐患

#### 	谈一谈插值器和估值器

​		1，插值器，根据时间（动画时长）流逝的百分比来计算属性变化的百分比，系统默认有匀速，加减速等

​		2，估值器，通过上面的插值器得到百分比计算出具体变化的值，系统默认有整形，浮点型，颜色估值器

​		3，自定义只需要重新他们的 evaluate 方法就可以了

#### android 10 的新特性

- 限制后台拉 activity
- 费系统应用无法获取到IMEI
- 外部存储的隔离存储，公共媒体文件的存储
- 后台地理位置权限
- 适配折叠屏
- 全面手势导航，应用充分利用全面屏，建议应用不要覆盖系统手势，否则可能导致手势冲突，影响用户使用习惯
- 应用使用黑色主题，灵活动态变化
- Android 10，受限制的非SDK接口增多了。

# 2019/9-25

​	今天请假办理离校手续

​	晚上修改mvp里面的bug，还没有完全修复。

# 2019/9-16

#### 如何优化Gradle 的构建速度

​	1，在 gradle 中 gradle.properties 文件中添加如下信息

```java
#开启守护线程
org.gradle.daemon=true
#设置jvm内存大小
org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
#开启并行编译任务
org.gradle.parallel=true
#启用新的孵化模式 
org.gradle.configureondemand=true
#开启 Gradle 缓存
org.gradle.caching = true
```

 注意对于内存的大小根据电脑内存地大小设置

​		2，打开 idea 的 Gradle 的 offinework 选项

​		3，在具体开发的 module 的build.gradle 文件中添加如下

```
 dexOptions { 
    //使用增量模式构建 
    incremental true 
    //最大堆内存 
    javaMaxHeapSize "8g"  //注意内存是自己电脑内存大小配置
    //是否支持大工程模式 
    jumboMode = true 
    //预编译 
    preDexLibraries = true 
    //线程数 
    threadCount = 8 
    } 
```

​		4，使用即时运行

​		5，不要使用动态依赖版本

​			 使用动态依赖版本不好的原因是他会创建不可重复的构建，而且他将导致 Gradle 每 24 小时监测依赖是否有新的版本，从而导致更长的构建时间

# 		2019/9-27

#### 	关于onConfigurationChanged(Configuration newConfig)方法介绍

​	newConfig:新的配置信息

​	当系统的配置信息发生改变时，系统会调用此方法。注意，只有在配置文件中处理了 configChanges 属性对应的设备配置，该方法才会被调用。如果发生设备配置与配置文件中设置的不一致，则 Activity 会被销毁并使用新的配置重建。

​	例如：当屏幕方向发生改变时，Activity 会被销毁重建，如果在 AndroidManifest 文件中处理屏幕方向信息如下：

```java
<activity android:name=".MainActivity"
 android:configChanges="orientation|screenSize">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
 </activity>
```

​	则 Activity 不会被销毁创建，而是会调用 onConfigurationChanged 方法

​	如果 ConfigChanges 只设置了 orientation，当其他设配信息发生改变时，Activity 依然会销毁重建，且不会调用 onConfigurationChanged 方法。

​	例如，在上面配置的情况下，如果语言变了额，Activity 就会冲洗创建，且不会调用 onConfigurationChanged 方法。

​	configChanges 设置取值

​	

| 值                 | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| mcc                | IMSI 移动国家/地区代码发横了变化，检测到了SIM并更新了MCC     |
| mnc                | IMSI 移动网络发生了变化，检测到了 SIM 并更新了 MNC           |
| locale             | 语言区域发生了变化， 用户为文本能选择了新的语言              |
| touchscreen        | 触摸屏发生了变化(这种情况同长不会发生)                       |
| keyboard           | 键盘类型发生了变化，例如插入了外置键盘                       |
| keyboardHidden     | 键盘无障碍功能发生了一些变化，例如用于显示了硬件键盘         |
| navigation         | 导航类型发生了变化(这种情况通常不会发生)                     |
| screenLayout       | 屏幕局部发生了变化， 可能是由激活了其他显示方式导致          |
| fontScale          | 字体缩放系数发生了变化 用户选择了行的全局字号                |
| uiMode             | 用户界面发生了变化，这可能是用户将设备放入桌面/车载基座导致  |
| orientation        | 屏幕方向发生了变化，用户旋转了设备，如果应用 API 大于 13 ，则还应该声明 screenSie 配置，因为设备在横向和纵向之间切换时，该配置也会变化 |
| screenSize         | 当前可用屏幕尺寸发生了变化，他表示当前可用尺寸相对于当前横比的变化， |
| smallestScreenSize | 物理屏幕尺寸发生了变化，他表示与方向无关的尺寸变化，因此只有在实际物理屏幕尺寸发生变化(如切换到外部显示器)时才会发生变化，此项目为 API13 中新增配置 |
| layoutDirection    | 布局方向发生了变化，例如 从左到右 更改为 从右到左。在API17中新增。 |

#### startService 和 bindService 的区别

##### startService 生命周期

​	onCreate --> onStartCommand --> onDestory

​	如果调用多次 startService，onCreate 只会执行一次，而onStartCommand 会执行多次

​	结束服务：调用 stopService ，生命周期执行 onDestroy 方法，并且多次调用 stopService 时，onDestroy 只有第一次会执行

##### bindService 生命周期

​	onCreate --> onBind --> onServiceConnected

​	如果调用多次 bindService，onCreate 和 onBind 都会在第一次执行，onServiceConnected会执行多次

​	结束服务：调用 unbindService 结束服务。unbindService 只能调用一次，onDestroy 也只能执行一次，多次调用会抛出异常

两者的区别

​	1，startService 开启后，与 activity 没有关联，不受影响，独立运行

​	2，bindService 开启后，与 activity 存在关联，退出activity 时必须调用 unbindService方法，否则会报 ServiceConnection 泄露的错误

同一个服务可以用两种方式 一起开启，没有顺序要求，onCreate 只会执行一次，关闭服务需要 stopService 和 unbindService 都被调用，没有顺序要求。但是如果只用一种方式关闭服务，不论是那种关闭方式，onDestroy 都不会执行，服务也不会关闭。



# 2019/9-28

#### 	车榜样和车榜样店铺端发布

​		版本为 1.2.5

#### 	Servicre 里面onStartCommand 的返回值

​	onStartCommand方法返回有4种 

 - START_STICKY  
 - START_NOT_STICKY  
 - START_REDELIVER_INTENT  
 - START_STICKY_COMPATIBILITY 

START_STICKY：如果 service 进程被 kill 掉。保留 service 状态为开始状态，但不保留递送的 Intent 对象，随后系统会尝试创建service，由于服务状态为开始状态，所以创建服务后一定会调用 onStartCommand 方法。如果在此期间没有任何命令传递到   servcie，南无Intent 将为 null。

START_NOT_STICKY ：“非粘性”的。使用这个返回值是，如果在执行完 onStartCommand 后，服务被异常 kill 掉，系统将不会重启该服务。

START_REDELIVER_INTENT  ：重传 Intent，使用这个返回值时 如果在执行完 onStartCommand 后，服务被 kill 掉，系统会重启服务。并将 Intent 值传入

START_STICKY_COMPATIBILITY ： START_STICKY 的兼容版本，但不保证服务被 kill 后一定能重启

#### app Dialgo 类型版本更新完成后自动打开 app(未解决)

使用了广播监听的方式，但是没有用，估计应该是最新版本有问题。等机会到了试一下

# 2019/9-29

#### 	学习约束布局

​		文件在UI 文件夹中，以后一定要多练习约束布局

#### 	使用AsyncTask 规则

- AsyncTask的类必须在UI线程加载（从4.1开始系统会帮我们自动完成）

- AsyncTask对象必须在UI线程创建

- execute方法必须在UI线程调用

- 不要在你的程序中去直接调用onPreExecute(), onPostExecute, doInBackground, onProgressUpdate方法

- 一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常

- AsyncTask不是被设计为处理耗时操作的，耗时上限为几秒钟，如果要做长耗时操作，强烈建议你使用Executor，ThreadPoolExecutor以及FutureTask

- 在1.6之前，AsyncTask是串行执行任务的，1.6的时候AsyncTask开始采用线程池里处理并行任务，但是从3.0开始，为了避免AsyncTask所带来的并发错误，AsyncTask又采用一个线程来串行执行任务


# 2019/9-30

#### 	什么是 ANR ，如何避免它?

​	 在 Android 上，如果你的程序有一段时间响应不灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应(ANR:Application NotResponding) 对话框。

​	不同的组件发生 ANR 的时间不一样，Activity 5 秒，BroadCastReceiver 是 10 秒，Service 20 秒 (均为前台)。

​	如果是开发机器上出现问题，我们可以查看 /data/anr/traces.txt 即可，最新的 ANR 信息在最开始的部分

- 主线程被 IO 操作
- 主线程存在耗时计算
- 主线程中的错误操作，比如 Thread.wait 或者 Thread.sleep 等 Android 系统会监控响应状况，一旦出现两种情况，则弹出 ANR 对话框
- 应用在 5 秒内未响应用户输入时间(按键或者触摸)
- BroadcastReceiver 未在 10 秒内完成相关的处理
- Serice 在特定的时间内无法处理完成 20秒

修正：

- 使用 AsyncTask 处理耗时 IO 操作
- 使用 Thread 或者 HandlerThread 时，调用 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND) 设置优先级，否则任然会降低程序响应，因为 Thread 的优先级和主线程相同。
- Activity onCreate 和 onResume 中 尽量避免耗时的代码，BroadcasatReceiver 中 onReceive 代码也要减少耗时，建议使用 IntentService

解决方案：

将所有耗时操作，比如访问网络，Socket通信，查询大量SQL，复杂逻辑计算都放在子线程中，然后通过 Handler，runnonUIThread ,AsyncTask，RxJava 等方式更新 UI，如果耗时需要用户等待，那么可以再界面上显示进度条。

#### 	修改 app 的bug

​	修改工作 app 的bug

#### 学习 MVVM

​	只学了一点