​	

# 7/30

绘制图片，跟随手指移动

```kotlin
class MultiTouchView(context: Context?, attrs: AttributeSet?) : View(context, attrs) {

    val bitmap = getAvatar(resources, 200)
    val paint = Paint(Paint.ANTI_ALIAS_FLAG)
    var downX = 0f
    var downY = 0f
    var offsetX = 0f
    var offsetY = 0f
    var originalOffsetX = 0f
    var originalOffsetY = 0f


    override fun onTouchEvent(event: MotionEvent): Boolean {
        when (event.actionMasked) {
            MotionEvent.ACTION_DOWN -> {
                downX = event.x
                downY = event.y
                originalOffsetX = offsetX
                originalOffsetY = offsetY
            }
            MotionEvent.ACTION_MOVE -> {
                offsetX = event.x - downX + originalOffsetX
                offsetY = event.y - downY + originalOffsetY
                invalidate()
            }
        }
        return true
    }


    override fun onDraw(canvas: Canvas) {
        canvas.drawBitmap(bitmap, offsetX, offsetY, paint)
    }

}
```

## 多点触摸

 	通过 **MotionEvent.getActionMasked()** 获取

​	 当第二个手指落下的时候，对应的 Aaction 为 ACTION_POINTER_DOWN 。这个时候就会包含两个信息 ：1，第一个手指的 x，y，index，id。第二个手指的 x，y，index，id。

​	接着当滑动的时候也会有两个信息。这个时候就需要处理到的获取那个手指的位置了。

## index，id

index

- 每个手指都会有个 index。从 0 开始往后排，第一个手指为 0，第二个为 1 ...... 。
- 通常情况下在 ACTION_DOWN 中同个 getX() 方法获取位置的时候默认使用的就是 0，也就是第一个手指。
- 如果需要获取别的手指的 位置，则需要使用其他的 index进行获取。
- 如果有两个手指，对应的 index 为 0,1。抬起第一个，则第二个的 index 就为 0。	

id

- 每个手指都会有个 index。从 0 开始往后排，第一个手指为 0，第二个为 1 ...... 。
- 获取 index 的 id：event.getPointerId(actionIndex)
- 如果有两个手指，第一个手指：index=0，id =0；第二个手指：index =1，id = 1。当第一个手指抬起后，则第二个手指的 index = 0，id = 1；id 是对这个手指进行一个唯一的标记，并且会保持不变。

通过 id 获取对应的 index：event.findPointerIndex(id) ；拿到 index 后，就可以通过 index 获取到对应手指的位置。

如果要追踪某个手指，则需要对对应手指的 id 进行保存，例如：在 ACTION_DOWN 中，获取到 第 0 个 id。在 MOVE 中通过保存的 id 获取的位置，然后对图片进行位置的偏移等。这时，如果按下了第二个手指，则只需要修改保存的id 为刚按下来手指的 id。接着第二个手指在滑动的时候就会获取到第二个手指的位置，然后事件就会被转移到第二个手指上。

这种情况叫做接力型，同一时刻只有一个 id 在起作用。下面看一个实际的例子：

 

```kotlin
class MultiTouchView(context: Context?, attrs: AttributeSet?) : View(context, attrs) {

    val bitmap = getAvatar(resources, dp2px(200f).toInt())
    val paint = Paint(Paint.ANTI_ALIAS_FLAG)
    var downX = 0f
    var downY = 0f
    var offsetX = 0f
    var offsetY = 0f
    var originalOffsetX = 0f
    var originalOffsetY = 0f

    //活跃的手指 Id,接力型。只有一个 id
    var tackingPointerId = 0


    override fun onTouchEvent(event: MotionEvent): Boolean {
        when (event.actionMasked) {
            MotionEvent.ACTION_DOWN -> {
                //拿到第0个手指的 Id
                tackingPointerId = event.getPointerId(0)
                downX = event.x
                downY = event.y
                originalOffsetX = offsetX
                originalOffsetY = offsetY
            }
            MotionEvent.ACTION_MOVE -> {
                //根据 id 拿到对应的 index
                val index = event.findPointerIndex(tackingPointerId)
                //拿到 index 位置 event.getX(tackingPointerId)
                offsetX = event.getX(index) - downX + originalOffsetX
                offsetY = event.getY(index) - downY + originalOffsetY
                invalidate()
            }
            MotionEvent.ACTION_POINTER_DOWN -> {
                //拿到刚按下去的 index
                val actionIndex = event.actionIndex
                //根据 index 拿到 id ，进行保存
                tackingPointerId = event.getPointerId(actionIndex)
                //将刚按下的手指位置进行保存，保证新的手指可以进行移动
                downX = event.getX(actionIndex)
                downY = event.getY(actionIndex)
                originalOffsetX = offsetX
                originalOffsetY = offsetY
            }
            MotionEvent.ACTION_POINTER_UP -> {
                //拿到抬起手指的 index
                val actionIndex = event.actionIndex
                //根据 index 获取到 id
                val pointerId = event.getPointerId(actionIndex)
                //如果抬起的手指是追踪的手指
                if (tackingPointerId == pointerId) {
                    val newIndex: Int
                    //如果抬起的是最后一个手指，事件需要交给他的前一个手指
                    if (actionIndex == event.pointerCount - 1) {
                        newIndex = event.pointerCount - 2
                    } else {
                        //如果抬起的不是最后一个手指，则事件交给最后一个处理
                        newIndex = event.pointerCount - 1
                    }
                    //获取到新index的 id 进行保存
                    tackingPointerId = event.findPointerIndex(newIndex)
                    //记录新的点的位置和偏移
                    downX = event.getX(newIndex)
                    downY = event.getY(newIndex)
                    originalOffsetX =  offsetX
                    originalOffsetY =  offsetY
                }

            }
        }
        return true
    }
    override fun onDraw(canvas: Canvas) {
        canvas.drawBitmap(bitmap, offsetX, offsetY, paint)
    }

}
```

