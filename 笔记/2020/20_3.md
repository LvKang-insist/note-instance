# 3/4

### 	suspend 函数的理解：

- 如果执行到 suspend 后，suspend 在 IO（阻塞）线程中，则会被挂起，协程外部会直接绕过协程继续往下执行，直到恢复后才会返回到协程体中继续执行
- 如果执行到 suspend 后， 没有被阻塞，则不会被挂起，然后就会顺序执行，也就是直接执行 suspend 函数 按顺序继续往下执行
- 如果是自定义的 suspend(也就是加了 suspendCoroutine )，可以拿到 continuation 。这种情况下 continuation 如果没有 resume/resumeWith ，则就会挂起。只有调用了 resume 之后才会继续执行协程体。
- suspend 函数并不代表挂起，还需要看实际的使用。
- suspend 函数如果没有挂起，则会继续往下执行，并返回结果，这种就是没有挂起。如果挂起了，则会返回一个挂起标志，外部知道这个函数挂起后就会继续往下执行。挂起的函数最终会将结果回调出去(这一步我们是看不到的)。

### 在 kotlin 中使用 注解处理器的问题：

​	在 app 的 gradle 中引入 注解处理器的 module 的时候一定要使用 kapt，不然无法生成 文件。如下所示：

```
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'


dependencies {
	.......
    implementation project(':libnavannotation') //注解库
    kapt project(":libnavcompiler") //注解处理器
}
```

# 3/5

启动协程和 resume 的理解

​	启动协程可通过  createCoroutine 或者 startCoroutine ，两者的区别是一个创建(创建后需要进行启动)，而另一是直接启动。

​	resume ：通过 createCoroutine 创建协程后 会返回一个 Continuation 。调用他的 resume 方法就可以执行协程了，官方对这个方法的解释为：**继续执行相应的协程，将[value]作为最后一个挂起点的返回值**。resume 可以携带一个参数

​	个人理解：resume 就是用来执行协程的(**注意这里不是执行 suspend** )。调用 resume 后协程就会开始执行，如果协程中有 suspend 函数，则会调用此函数(并且隐式的传递一个 Continuation)。执行 suspend 会有下面这几种情况

- 自定义的 suspend（使用了 suspendCoroutine ），这种情况下可以获取到 Continuation。通过 continuation 就可以控制这个suspend 函数是否挂起，**如果调用了 resume**，就会继续跳出 suspend 函数，继续执行 协程体（也就是恢复），**如果没有调用**，则 suspend 函数会被挂起，直到调用 resume 为止。
- 如果是普通的 suspend 函数，且**是 IO 线程**，则会被挂起，协程体不会继续往下执行，但协程体外会继续执行（知道挂起的恢复后协程体继续往下执行）。如果不是 IO 线程，则意味着没有挂起，此时会将 supsend 函数执行完，接着返回到协程体继续执行。

# 3/6

​		Kotlin 使用注解处理器遇到的一些问题：

- 首先注解处理器肯定是一个 javaLibrary 。你需要在 app 项目中依赖他，注意依赖的方式一定要用 kapt，如下：

  ```kotlin
  apply plugin: 'kotlin-kapt'
  
  dependencies{
  	//注解 library
      implementation project(':libnavannotation')
      //注解处理器 library
      kapt project(":libnavcompiler")
  }
  ```

- 如果你注解处理器使用 java 写的，那这样就已经好了

- 如果使用 kotlin 写的，那么还需要修改一下东西

  注解处理器的gradle 文件：

  ```kotlin
  apply plugin: 'java-library'
  apply plugin: 'kotlin'
  apply plugin: 'kotlin-android-extensions'
  tasks.withType(JavaCompile) {
      options.encoding = "UTF-8"
  }
  
  dependencies {
      implementation fileTree(dir: 'libs', include: ['*.jar'])
      implementation project(':libnavannotation')
  
      implementation this.rootProject.depsLibs.fastjson
      //auto service
      implementation  this.rootProject.depsLibs.autoservice
      implementation this.rootProject.depsLibs.corektx
      annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'
  }
  
  sourceCompatibility = "8"
  targetCompatibility = "8"
  ```

  接着需要在 注解处理器的 library 的 main 文件夹下创建一个 resources 文件，路径为 src/main/resources/META-INF/service/javax.annotation.processing.Processor

  ![image-20200307101005094](20_3.assets/image-20200307101005094.png)

  

    在文件中注明注解处理器的全类别即可：如上图所示。

- 最后注意一下，注解处理器的代码一定要没有问题，我就是 将 || 写成了 && ，才遇到了一系列的坑

# 3/7

​	协程的创建理解：

- 创建一个协程会有两个 Continuation。一个是传入的 Continuation，还有一个是 返回的 Continuation，传入的 Continuation 是协程执行完后回调的 Continuation，返回的则是协程的本地，协程内部的 resume 完成了之后他才会 回调我们传入的 Continuation

  ```kotlin
      // x ：协程的本体，内部的 resume 都执行完了之后才会回调我们传入的 Continuation
      val x = suspend {
  
          getData("http://www.baidu.com")
  
          //传进去的 Continuation 是协程执行完后回调的 Continuation
      }.createCoroutine(object : Continuation<String> {
          override val context: CoroutineContext = Disp()
          override fun resumeWith(result: Result<String>) {
              println("result" + result.getOrThrow())
          }
      })
      x.resume(Unit)
  ```

  首先是 使用返回值进行 resume。这样相当于启动协程，suspend 里面(协程)就会得到执行，协程的内部会进行很多的挂起恢复操作，但是协程本身也是一个 continuation，当协程内部执行完后，就会调用 continuation，这个 continuation 就是我们在 createCoroutine 中传入的。最终他的 resumeWith 会得到执行，到此协程执行完成。

协程的拦截器：

​	注意上面的代码，在 createCoroutine 下面的第一句使用了 拦截器 Disp()，

```kotlin
//自定义一个拦截器
class Disp() : ContinuationInterceptor {
    override val key: CoroutineContext.Key<*> = ContinuationInterceptor

    override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> {
        println("拦截")
        return continuation
    }
}
```

​	注意 上面使用拦截器的位置，在 执行 x.resume 是，首先会执行拦截器的内容，拦截器接收一个 Continuation，并且返回一个 Continuation。这样我们就可以在这里进行一系列的操作，例如换线程等。

​	那么 拦截器接收的 continuation 到底是谁的呢？

​	其实就是 suspend{} 执行完后要返回的 continuation，调用它的 resume 就想当于 回调 我们在 createCoroutine 传入的 continuation。