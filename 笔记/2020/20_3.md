# 3/4

### 	suspend 函数的理解：

- 如果执行到 suspend 后，suspend 在 IO（阻塞）线程中，则会被挂起，协程外部会直接绕过协程继续往下执行，直到恢复后才会返回到协程体中继续执行
- 如果执行到 suspend 后， 没有被阻塞，则不会被挂起，然后就会顺序执行，也就是直接执行 suspend 函数 按顺序继续往下执行
- 如果是自定义的 suspend(也就是加了 suspendCoroutine )，可以拿到 continuation 。这种情况下 continuation 如果没有 resume/resumeWith ，则就会挂起。只有调用了 resume 之后才会继续执行协程体。
- suspend 函数并不代表挂起，还需要看实际的使用。
- suspend 函数如果没有挂起，则会继续往下执行，并返回结果，这种就是没有挂起。如果挂起了，则会返回一个挂起标志，外部知道这个函数挂起后就会继续往下执行。挂起的函数最终会将结果回调出去(这一步我们是看不到的)。

### 在 kotlin 中使用 注解处理器的问题：

​	在 app 的 gradle 中引入 注解处理器的 module 的时候一定要使用 kapt，不然无法生成 文件。如下所示：

```
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'


dependencies {
	.......
    implementation project(':libnavannotation') //注解库
    kapt project(":libnavcompiler") //注解处理器
}
```

# 3/5

启动协程和 resume 的理解

​	启动协程可通过  createCoroutine 或者 startCoroutine ，两者的区别是一个创建(创建后需要进行启动)，而另一是直接启动。

​	resume ：通过 createCoroutine 创建协程后 会返回一个 Continuation 。调用他的 resume 方法就可以执行协程了，官方对这个方法的解释为：**继续执行相应的协程，将[value]作为最后一个挂起点的返回值**。resume 可以携带一个参数

​	个人理解：resume 就是用来执行协程的(**注意这里不是执行 suspend** )。调用 resume 后协程就会开始执行，如果协程中有 suspend 函数，则会调用此函数(并且隐式的传递一个 Continuation)。执行 suspend 会有下面这几种情况

- 自定义的 suspend（使用了 suspendCoroutine ），这种情况下可以获取到 Continuation。通过 continuation 就可以控制这个suspend 函数是否挂起，**如果调用了 resume**，就会继续跳出 suspend 函数，继续执行 协程体（也就是恢复），**如果没有调用**，则 suspend 函数会被挂起，直到调用 resume 为止。
- 如果是普通的 suspend 函数，且**是 IO 线程**，则会被挂起，协程体不会继续往下执行，但协程体外会继续执行（知道挂起的恢复后协程体继续往下执行）。如果不是 IO 线程，则意味着没有挂起，此时会将 supsend 函数执行完，接着返回到协程体继续执行。