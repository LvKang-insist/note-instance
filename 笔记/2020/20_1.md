# 20/1-3

Kotlin 的高阶函数：函数可以作为一个参数进行传递，也可以作为一个返回值。

内联函数：在高阶函数中，内联函数是一个非常重要的概念。

定义：inline fun ....

原因：如果将函数作为参数进行多次传递，会造成比较的的开销和性能问题，每调用一次传入的函数，就相当于创建了一个新的对象，因为每个匿名函数就是一个对象。

概念：如果使用了 inline 进行标记。在代码的执行过程中，如果调用了内联函数，就会把内联函数体中的内容直接放在调用的地方，从而避免创建 匿名对象。

内联函数中的 return

​	默认会从调用出返回，等

内联属性

​	其实就是属性的 get / set 方法，会在调用的地方执行，和上面的一样

### 观察者模式

​	定义对象之间一对多的依赖，从而一个发生变化其他的都会改变。

​	[观察者模式](https://blog.csdn.net/baidu_40389775/article/details/103827548)

# 20/1-4

集合的变化与序列

​	filter，map，flatmap

​	注意恶汉序列和懒汉序列

集合的聚合操作

​	sum ，reduce，fold，zip 等

SAM 转换

​	一个抽象方法

​	在 Java 中，如果调用某个方法，且这个方法测参数是一个接口。接口中只有一个方法，那么就可以传入一个 Lambda 表达式 作为转换参数。

​	在 Kt 中，如果调用某个 java 方法，且这个方法测参数是一个接口。接口中只有一个方法，那么就可以传入一个 Lambda 表达式（必须是 java 方法）作为转换参数。

# 20/1-6

​	做了几个 Kotlin 的例子，类型的深入了解

​	理解装饰者模式：无数的装饰者和一个被装饰者

​	问题：被装饰后，如果要取消装饰会变得比较困难

​	整理 装饰者的笔记

# 20/1-11

	 定义在 类中的扩展函数，必须在类中使用别的类对象来调用

```
//所有的类都可以调用，模仿 run
inline fun <T> T.lv(t: T.() -> Unit) {
    t()
}
```

泛型的形变：

out：只读不写

in：只写不读，某些情况可读。但是读出来的只能是 Any

星投影

out：只读，默认读出的是上限类型 Any。也可指定上限

in：读出的是 Any?，不写。写入的是下限(Nothing)无法定义。所以不能写入

