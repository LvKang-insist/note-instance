# 5/4

​	IOC，控制反转的缩写，一般分为两个内容，依赖反转和依赖注入，一般主要用到的哈斯依赖注入

​	Android 中主要就是用 反射+注解来实现

​	例如：使用反射+注解来实现自动findViewById 和 点击事件，只要给对应的字段或者方法添加指定的注解，即可自动进行 findViewById 和 点击事件的实现。

​	例子详解：Android进阶之旅/IOC

# 5/5

​	熟悉 AndroidStudio 插件开发流程，回顾 AsyncTask 的源码

# 5/7

​	查看 创建 Resource 的源码，从 调用 getResources 开始，会一直调到 Context 中的 getResource 方法，该方法为 抽象方法，具体的实现是 ContextImpl 类，该类需要从 源码中查看，as 中无法查看。

​	 在 ContextImpl 类中 会通过 createResources 方法创建，具体的创建时通过 ResourcesManager 进行创建的。

​	在 ResourcesManager 中 会判断是进行缓存等，最终创建 Resources 对象，该对象是通过 new 创建的。有好几个构造函数，在不同的源码种，创建的方式也有可能不同。但是最终结果都差不多。

​	Resources 创建成功后，AssecsManager 也会创建出来。AssecsMaanger 中添加了一些路径，比较重要的就是apk 的路径，不同的版本添加的方式不一致。但是最终调用的方法是一致的。他最终会调用到 native 层的代码，然后就会加载资源文件。

​	其实 android 系统中实际上对资源进行管理的类是 AssetManager，每个 Resources 类都会关联一个 AssetManager，Resources 将大多数的资源操作委托给了 AssetManager。

# 5/8

 LiveData：负责通知订阅者数据发送改变，liveData 发送数据后，所有订阅改 LiveData 的订阅者都会被调用，订阅LiveData 一共有两种方式，分别是 observer 和 observerForever。

- Observer

   使用 observe 订阅 liveData， 当前页面销毁后，liveData 会自动解除绑定。并且 liveData 发送数据后，如果页面不可见，则数据会被保存，当页面可见时，数据会发送到 订阅者中

- observerForever

   和 observer 的区别就是当页面不可见时，也会接收到数据。

ViewModel：用来管理 LiveData，一般情况下，ViewModel 需要持有者 LiveData。那么ViewModel 的作用是啥呢？

查看 创建 Resource 的源码，从 调用 getResources 开始，会一直调到 Context 中的 getResource 方法，该方法为 抽象方法，具体的实现是 ContextImpl 类，该类需要从 源码中查看，as 中无法查看。


- 用来管理 LiveData，注意，ViewModel 要持有 LiveData。当页面不可见时，ViewModel 会被销毁，对应的 LiveData 会被销毁，这样就可以避免一些内存泄漏的问题。ViewModel 可以感知到 activity 的生命周期。
- 如果 LiveData 有多个订阅者，则就不要被 ViewModel 持有了，如果当 ViewModel 对应的页面销毁后，则LiveData 就没啥用了。

Litecycle：管理Activity+Fragment 的生命周期

getLifecycle().addObserver(new MyObserver()) ，添加一个观察者，当生命周期发送变化时，MyObserver 中对应的方法会被调用。

# 5/9

setContentView 流程

​		创建 DecorView -> 加载系统资源布局 -> 将系统资源布局 add 进 DecorView 中 -> 找到 id 为 @android:id/content 的 Fragment -> 将从 setContentView 传入的 layout 加载进这个id中

​		知道他的创建流程后，我们可通过以下方法设置布局，不用调用 setContentView 

```java
val view = LayoutInflater.from(this).inflate(layout(), null)
val decorView = window.decorView
val frameLayout = decorView.findViewById<FrameLayout>(android.R.id.content)
frameLayout.addView(view)
```

AppCompatActivity 和 Activity 中的 setContentView 有什么不同

​		先将一个例子，在一个 activity 的布局中 放一个 imageView，然后 activity 分别继承 这两个 activity 进行打印，最后你会发现 两次打印的结果不同。

​		 AppCompatActivity 设置 setContentView 调用的 是 AppCompatDelegateImpl 中的方法，这个类实现了一个接口 LayoutInflater.Factory2 ，然后调用 setFactory2 传入了自己(LayoutInflater.from(mContext) 是一个单例)，这样设置完之后使用 LayoutInflater 加载布局的时候就会调用 Factory2 中的方法，也就会调用到 AppCompatDelegateImpl 中，在 AppCompatDelegateImpl 实现的接口方法中，拦截了 View 的创建，将其修改为对应的具有兼容性的 View，如下部分代码：

```java
// We need to 'inject' our tint aware Views in place of the standard framework versions
switch (name) {
    case "TextView":
        view = createTextView(context, attrs);
        verifyNotNull(view, name);
        break;
    case "ImageView":
        view = createImageView(context, attrs);
        verifyNotNull(view, name);
        break;
    case "Button":
        view = createButton(context, attrs);
        verifyNotNull(view, name);
        break;
}
```

# 5/12

换肤框架的流程

1，在 Activity 的 onCreate 之前拦截 View 的创建

2，拦截后 ，创建 VIew 的时候解析 VIew 的属性，保存到 SkinView 中

```
val skinAttrs: List<SkinAttr> = SkinAttrSupport.getSkinAttrs(context, attrs)
val skinView = SkinView(view, skinAttrs)
```

3，将 skinView 保存到 list 中。最后将 list 保存到 map 中。map 中的 键为activity。值为 list。

4，获取皮肤路径，加载皮肤，初始化资源管理

5，遍历 map，接着遍历 list。遍历需要换肤的属性

6，获取资源Resources，然后获取皮肤中对应的资源。进行换肤

