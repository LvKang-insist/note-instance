# 5/4

​	IOC，控制反转的缩写，一般分为两个内容，依赖反转和依赖注入，一般主要用到的哈斯依赖注入

​	Android 中主要就是用 反射+注解来实现

​	例如：使用反射+注解来实现自动findViewById 和 点击事件，只要给对应的字段或者方法添加指定的注解，即可自动进行 findViewById 和 点击事件的实现。

​	例子详解：Android进阶之旅/IOC

# 5/5

​	熟悉 AndroidStudio 插件开发流程，回顾 AsyncTask 的源码

# 5/7

​	查看 创建 Resource 的源码，从 调用 getResources 开始，会一直调到 Context 中的 getResource 方法，该方法为 抽象方法，具体的实现是 ContextImpl 类，该类需要从 源码中查看，as 中无法查看。

​	 在 ContextImpl 类中 会通过 createResources 方法创建，具体的创建时通过 ResourcesManager 进行创建的。

​	在 ResourcesManager 中 会判断是进行缓存等，最终创建 Resources 对象，该对象是通过 new 创建的。有好几个构造函数，在不同的源码种，创建的方式也有可能不同。但是最终结果都差不多。

​	Resources 创建成功后，AssecsManager 也会创建出来。AssecsMaanger 中添加了一些路径，比较重要的就是apk 的路径，不同的版本添加的方式不一致。但是最终调用的方法是一致的。他最终会调用到 native 层的代码，然后就会加载资源文件。

​	其实 android 系统中实际上对资源进行管理的类是 AssetManager，每个 Resources 类都会关联一个 AssetManager，Resources 将大多数的资源操作委托给了 AssetManager。

# 5/8

 LiveData：负责通知订阅者数据发送改变，liveData 发送数据后，所有订阅改 LiveData 的订阅者都会被调用，订阅LiveData 一共有两种方式，分别是 observer 和 observerForever。

- Observer

   使用 observe 订阅 liveData， 当前页面销毁后，liveData 会自动解除绑定。并且 liveData 发送数据后，如果页面不可见，则数据会被保存，当页面可见时，数据会发送到 订阅者中

- observerForever

   和 observer 的区别就是当页面不可见时，也会接收到数据。

ViewModel：用来管理 LiveData，一般情况下，ViewModel 需要持有者 LiveData。那么ViewModel 的作用是啥呢？

查看 创建 Resource 的源码，从 调用 getResources 开始，会一直调到 Context 中的 getResource 方法，该方法为 抽象方法，具体的实现是 ContextImpl 类，该类需要从 源码中查看，as 中无法查看。


- 用来管理 LiveData，注意，ViewModel 要持有 LiveData。当页面不可见时，ViewModel 会被销毁，对应的 LiveData 会被销毁，这样就可以避免一些内存泄漏的问题。ViewModel 可以感知到 activity 的生命周期。
- 如果 LiveData 有多个订阅者，则就不要被 ViewModel 持有了，如果当 ViewModel 对应的页面销毁后，则LiveData 就没啥用了。

Litecycle：管理Activity+Fragment 的生命周期

getLifecycle().addObserver(new MyObserver()) ，添加一个观察者，当生命周期发送变化时，MyObserver 中对应的方法会被调用。

# 5/9

setContentView 流程

​		创建 DecorView -> 加载系统资源布局 -> 将系统资源布局 add 进 DecorView 中 -> 找到 id 为 @android:id/content 的 Fragment -> 将从 setContentView 传入的 layout 加载进这个id中

​		知道他的创建流程后，我们可通过以下方法设置布局，不用调用 setContentView 

```java
val view = LayoutInflater.from(this).inflate(layout(), null)
val decorView = window.decorView
val frameLayout = decorView.findViewById<FrameLayout>(android.R.id.content)
frameLayout.addView(view)
```

AppCompatActivity 和 Activity 中的 setContentView 有什么不同

​		先将一个例子，在一个 activity 的布局中 放一个 imageView，然后 activity 分别继承 这两个 activity 进行打印，最后你会发现 两次打印的结果不同。

​		 AppCompatActivity 设置 setContentView 调用的 是 AppCompatDelegateImpl 中的方法，这个类实现了一个接口 LayoutInflater.Factory2 ，然后调用 setFactory2 传入了自己(LayoutInflater.from(mContext) 是一个单例)，这样设置完之后使用 LayoutInflater 加载布局的时候就会调用 Factory2 中的方法，也就会调用到 AppCompatDelegateImpl 中，在 AppCompatDelegateImpl 实现的接口方法中，拦截了 View 的创建，将其修改为对应的具有兼容性的 View，如下部分代码：

```java
// We need to 'inject' our tint aware Views in place of the standard framework versions
switch (name) {
    case "TextView":
        view = createTextView(context, attrs);
        verifyNotNull(view, name);
        break;
    case "ImageView":
        view = createImageView(context, attrs);
        verifyNotNull(view, name);
        break;
    case "Button":
        view = createButton(context, attrs);
        verifyNotNull(view, name);
        break;
}
```

# 5/12

换肤框架的流程

1，在 Activity 的 onCreate 之前拦截 View 的创建

2，拦截后 ，创建 VIew 的时候解析 VIew 的属性，保存到 SkinView 中

```
val skinAttrs: List<SkinAttr> = SkinAttrSupport.getSkinAttrs(context, attrs)
val skinView = SkinView(view, skinAttrs)
```

3，将 skinView 保存到 list 中。最后将 list 保存到 map 中。map 中的 键为activity。值为 list。

4，获取皮肤路径，加载皮肤，初始化资源管理

5，遍历 map，接着遍历 list。遍历需要换肤的属性

6，获取资源Resources，然后获取皮肤中对应的资源。进行换肤

# 5/12

换肤框架类职责

SkinType：枚举类，换肤的类型，例如 textColor,background 等，在内部实现实现换肤的逻辑

```java
enum class SkinType(val resName: String) {

    TEXT_COLOR("textColor") {
        @RequiresApi(Build.VERSION_CODES.M)
        override fun skin(view: View, resName: String) {
            val skinResource = getSkinResource()
            val color = skinResource.getColorByName(resName)
            if (color != null) {
                (view as AppCompatButton).setTextColor(color)
            }
        }
    };
    //...
    abstract fun skin(view: View, resName: String)
    fun getSkinResource(): SkinResource {
        return SkinManager.getSkinResource()
    }
}
```

SkinAttr：保存需要换肤的资源名称和 SkinType，

SkinView：保存View 和 List<SkinAttr> ，

SkinAttrSupport：解析出需要替换皮肤的属性

BaseSkinActivity：拦截 View 的创建，解析属性，并保存。

SkinManager：单例，加载新皮肤，默认皮肤等。

SkinResource：资源管理，用来获取皮肤包中的资源

# 5/14

​	改了一个 bug，最终的原因是 AssetsManager 被 close 了。。。

​	完善换肤框架

​	回顾 AIDL 多进程通信：分为 客户端和服务端，今天重新试了一下，做了两个 app，一个服务和一个客户端，这里贴一下客户端的代码，方便查找：

```java
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        bind_service.setOnClickListener {
            val intent = Intent()
            intent.action = "com.qs.essayjoke.UserServcie"
            intent.`package` = "com.qs.essayjoke"
            bindService(intent, service, Context.BIND_AUTO_CREATE)
        }
    }

    val service = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            val stub = User.Stub.asInterface(service)
            Log.e("-----名称", stub.userName)
            Log.e("-----密码", stub.userPwd)
            Toast.makeText(
                this@MainActivity,
                stub.userName + "----" + stub.userPwd,
                Toast.LENGTH_LONG
            ).show()

        }
        override fun onServiceDisconnected(name: ComponentName?) {
        }
    }
}
```

这里有一个比较重要的地方，绑定服务是通过隐式意图进行绑定的。

还有一个就是 客户端的AIDL 文件 必须和 服务端的一致，并且 aidl 的包名也要一致。

# 5/16

​	AndroidX 中ViewPage 懒加载

​	原理的拦截者被 setMaxLifecycle 取代。这个方法的作用是为 Fragment 的状态设置上限，如果当前的状态超过了设置的上下，就会被强制降到对应的状态。下面是对应的状态

```
static final int INITIALIZING = 0;     // Not yet created.
static final int CREATED = 1;          // Created.
static final int ACTIVITY_CREATED = 2; // Fully created, not started.
static final int STARTED = 3;          // Created and started, not resumed.
static final int RESUMED = 4;   
```

​	例如设置的状态是 RESUMED , 如果 fragment 状态低于 设置的状态，则状态变为 RESUMED。如果当前状态是 STARTED ，那么接下来 fragment 的状态会变成 RESUMED 。如果 当前状态是 RESUMED，则什么也不用做

​		懒加载的新方案：

​		**FragmentPagerAdapter** 接收一个 behavior 值，系统内置了两个。

​		如果值为  **BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT** ，就将上一个 fragment 的状态设置为 STARTED ，将要显示的 设置为 RESUMED 。反之使用 setUserVisibleHint() 设置 fragment 的可见性

​		也就是说 使用这个值后，打开一个 fragment 他会调用 resume 方法，并且让上一个 fragment 生命周期处于 start ，这样一来每次打开 fragment 都会执行 resume 方法。我们只需要在其中做一下判断即可。

```kotlin
abstract class BaseFragment : Fragment() {

    private var isLazyLoad = false


    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(layout(), container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        bindView(view)
    }

    override fun onResume() {
        super.onResume()
        if (!isLazyLoad) {
            isLazyLoad = true
            lazyLoad()
        }
    }

    /**
     * 加载布局
     */
    abstract fun layout(): Int

    /**
     * 逻辑处理
     */
    abstract fun bindView(rootView: View)

    /**
     * 懒加载
     */
    open fun lazyLoad() = Unit

}
```

​	ViewPager2 的拦截载

​	其实内部直接使用的就是上面这种方式，所以上面的 懒加载对 ViewPager2 也有效

# 5/20

​	换肤框架在 MVVM 中遇到的问题

​	如：在布局中使用的是 LinearLayout ，则 Databinding 会生成一个实现类，实现类中也会是 LinearLayout，但是在换肤时，拦截 View的创建后，会将 LinearLayout 转为 AndroidX 下面的 LinearLayout，导致实际的类型和 DataBinding 中的实现类中的类型不一致，导致报错，

​	解决的办法：将布局中的 LinearLayout 直接改为 AndroidX 下面的即可。

# 5/27

​	Canvas ：

```java
Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
Canvas c = new Canvas(b);
```

​	将绘制的内容保存在 bitmap 中

# 5/28

​	内存抖动

​		在程序中，每创建一个对象，就会给他分配一块内存，对应的程序可用的内存就会少一块；当程序内存被占用到一定程度后，gc 就会开始工作，去释放一下不在使用的内存。

​		android 中 View 的 onDraw 中如果写了创建对象的代码，在界面频繁刷新的时候，就会创建大量只被使用一次的对象，这就会导致内存不断地攀升；然后很快 gc 就会开始工作，这些 onDraw 中创建出来的对象会被回收掉。这些都没有啥大问题。

​		问题在于频繁的创建这些对象会导致内存不断攀升，然后 gc 会进行回收。回收完了之后 内存还会不断的攀升，紧接着又会进行回收。最终导致一种循环，一种在短时间内反复的增长和回收的循环

​		这种循环的状态就像是水波纹的颤动一样，翻译为 Memory churn 。android 官方文档中把它翻译为 内存抖动。

