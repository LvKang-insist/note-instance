### Activity 异常情况下的生命周期

- 资源相关的系统配置发生改变导致 activity 被杀死并重新创建

  如横竖屏切换时：activity 被杀死，即调用 onPause，onStop，onDestroy，同时调用 onSaveInstanceState 保存 activity 的状态，这个方法在 activity 异常终止时调用。重新创建时，系统会调用 onRestoreInstanceState 和 onCreate 方法，通过这两个可以判断 activity 是否被重建

  如果不想 activity 屏幕旋转重建，可以设置 configChange=“orientation|screenSize”

- 资源不足导致低优先级的 activity 被杀死

  1，前台 activity，与用户交互的 activity，优先级最高

  2，可见非前台，比如出现了一个弹窗，导致 activity 可见但不能进行交互

  3，后台activity，已经被暂停，执行了 onStop 方法，优先级最低

### 如何判断图片需要放在那些文件夹中

​	ldpi：240 X 320

​	mdpi：320 X 480

​	hdpi：480 X 800

​	xhdpi：960 X 720

​	xxhdpi：1280 X 720

### Integer 和 int 之间的区别

- Integer 是 int 的包装类，必须实例化之后才可以使用，而 int 则不需要实例化
- int 是 java 中一种基本的数据类型，
- integer 的对象时引用，当 new 一个 Integer 时，实际上是生成的一个指针指向此对象。而int 则是直接存储数据值
- Integer 默认值为 null，int 默认值为 0

### String 转换 integer 的方式以原理

​		

### Activity 切换到 后台，在切换到前台的生命周期

A调用： onCreate  -> onStart -> onResume A 可见，接着 A 跳转 B 时， 接着调用 onPause。

B调用： onCreate ->onStart ->onResume B 可见，这时 A 调用 onStop，当 A 回到前台时：B调用 onPause，然后 A 调用 onReStart -> onStart -> onResume。然后b 调用 onStop -> onDestory 。

### 弹出 Dialog 时按 Home 键 Activity 的生命周期

​	弹出dialog：onCreate() -> onStart() -> onResume

​	按下Home：onCreate() -> onStart() -> onResume -> onPause() -> onStop()  	

​	为啥弹出 dialog 时没有执行 onPause 方法？

​		我们弹出的 AlertDialog 对话框实际上是 Activity 的一个组件，此时的activity 并不是不可见，而是被一个布满屏幕的组件覆盖掉了，所以没办法进行操作。当点击了 Home 时 activity 才进入了后台。

###  对 BroadcastReceiver 的了解？ 

​	广播接收者，需要在清单文件中进行注册，还需要声明那种类型的广播能被广播接收器接收到。

​	发送广播的方式：

​		1，标准广播：广播发出后，符合要求的广播几乎会在同一时间接收到广播

​		2，有序广播：广播发出后，同一时刻只能有一个广播接收到。可以选择继续传递，也可以拦截此广播。优先级高的会先接收到广播。

​	本地广播

​		本地广播是一种只能被本程序广播接收器所接收的广播

### 动态广播和静态广播有什么不同

- 动态的比静态安全
- 静态在 App 启动时候就初始化了，动态则在代码中初始化
- 静态需要在 清单文件中配置，动态不需要
- 静态广播的生存期比动态长很多
- 动态广播优先级比静态的高

### Android 项目构建过程

​	1，AAPT(Android Asset PackagingTool) 工具会打包应用中的资源文件，如 AndroidManifest.xml ，layout 中的布局等，并将xml 文件编译为 二进制形式，当然 assets 中的文件不会被编译。图片及 raw 文件资源会保持原来的形态，raw 中的资源会生出资源 id，AAPT 编译完成之后会生成 R.java 文件。

​	2，AIDL 工具会将所有的 aidl 接口转化为 java 接口

​	3，所有的 java 代码，包括 aidl 和 R.java 都会被 java 编译器编译成 .class 文件，

​	4，Dex 工具会将上述产生的 .class 文件以及第三方库及其他的 .class 文件编译成 .dex文件(dex 文件是Dalvik 虚拟机可以执行的格式)，dex 文件最终被打包进 APK文件。

​	5，ApkBuilder 工具会将编译过的资源文件 及 未编译过的(如 图片等) 以及 .dex 文件 打包成 APK 文件

​	6，生成 apk 文件后，需要对齐签名才可安装到设备，平时测试会使用 debug keystore，当正式版发布时，必须使用 release 版的 keystore 进行签名。

​	7，如果对 APK 正式签名，还需要使用 zipalign 工具对 APK 进行对齐操作，这样的好处是应用运行时会提高速度，但是会相应增加内存开销。

### ArrayList 和 LinedList 的区别

​	ArrayList：底层采用数组的方式，查询快，增删慢，允许 null 元素，线程是不安全的，从 JDK 1.8 开始 默认初始容量为 10

​	LinkedList：底层采用链表，可以将元素插入到首部或者尾部，线程是不安全的，增删快，查询较慢。

### 静态代理和动态代理

​	静态代理：主要有 接口，被代理类，代理类 。被代理类 和 代理类都实现 接口。最后给 代理类传入 被代理类的对象，然后 就可以通过 代理类去调用 被代理类的 方法，并且可在代理类中完成一些额外的操作。这样的好处就是：在 一个类不能被直接修改 或者是 不想直接创建他的对象时，可以 new 一个代理类，通过这个代理 进行 控制，并且很容易添加一些新的方法。

​	动态代理：主要有 接口，被代理类。通过 Proxy.newProxyInstance 方法 可以生成一个方法，在这个方法中可以直接调用被代理类的方法，并可以添加一些额外的操作。如下所示：

```java
// 接口
interface Subject {
    void sub();
}

// 被代理类
class RctSub implements Subject {
    @Override
    public void sub() {
        System.out.println("rct");
    }
}


private static RctSub rct;
public static void main(String[] args) {
        rct = new RctSub();
        //创建动态代理
        Subject subject = create(Subject.class);
        //调用 sub 会执行下面的 invoke 方法，
        subject.sub();
}

public static <T> T create(final Class<T> cls) {
        return (T) Proxy.newProxyInstance(cls.getClassLoader(), new Class[]{cls}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                //调用被代理类的方法，
                return method.invoke(rct, args);
            }
        });
    }
```

好处是：在程序运行期间，会自动生成代理类，代理类逻辑 和 业务逻辑 进行解耦。

### Bundle 传递数据为什么不支持对象，Serializable 和 Parcelable 的区别

因为 Bundler 只支持基本数据类型的传输，所以在传递对象时，需要将对象进行序列化，被序列化的对象可以被保存在本地文件中，也可以在网络，IPC 直接进行传输。

Serializable ：java 自带的序列化，实现该接口可以实现对象的序列化，被序列化的对象可直接使用 IO 流进行读写等操作。如果被序列化的对象中有引用类型，那么这个引用类型也必须是可序列化的，否则将无法被序列化

Parcelable ：android 的序列化，本质是将对象分解为基本数据类型，分解之后的每一个部分都是 Bundle 所支持的类型。

区别：

​			Serializable  将对象转换为可存储的状态，使用非常简单，但是效率很低，在序列化的过程中会有大量的 IO 操作，适合将对象保存在本地，或者通过网络传输。

​		    Parcelable  将对象分解为基本数据类型，使用比较复杂，但是效率高，主要用于内存中的序列化。

### JVM 内存模型 和 内存区域

- 内存模型：

  java 内存模型规定了所有的变量都是存储在主内存中，每个线程都有自己的工作内存，**线程的工作内存中保存了该线程用到的变量的主内存副本拷贝**，也就是说每个子线程中都有用到的主内存中的变量都是从主内存拷贝的副本。线程对变量的所有操作都必须在工作内存中，不能直接读写主内存中的变量。不同的线程直接也无法方法对方工作内存中的变量。线程之间的值传递需要用主内存来完成。

- 内存区域：

   ![img](19_10.assets/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31312f30352f356264666365353738633035352e6a7067.jpg) 

  程序计数器：

  他是一个比较小的控件，可以看作是当前线程所执行的字节码的行号指示器。如果线程执行的是 java 方法，这个计数器记录的就是正在执行的虚拟机字节码指令的地址；如果是 Native方法，他则为空。此内存区域是唯一一个没人规定任何 OOM 的区域

  虚拟机栈：

  虚拟机栈描述的是 java 方法执行的内存模型：每个方法在执行的同时会创建一个栈用于存储局部变量表，操作数栈，方法出口等信息。每一个方法从调用到执行完的过程就对应着一个栈在虚拟机中入栈到出栈的过程。

  本地方法栈：

  和虚拟机栈类似，只不过是虚拟机栈Wie java 方法服务，而本地方法栈为虚拟机执行 Native 方法服务。

  堆：

  用来存放对象的实例。

  方法区：

  用于储存已经被虚拟机加载的类信息、常量，静态变量等待

### Android 中的源码用到了那些设计模式

​	建造者模式：AlertDialog，OkHttp等。

​	模板模式：AsyncTask等，

​	装饰者模式：流对象，如：InputStream等。

​	观察者模式：java 内置的有观察者模式，可以直接使用。还有 liveData，RxJava，等。

​	工厂模式：线程池中，如 LayoutInflater，Bitmap，Retrofit 等。

​	单例模式：LayoutInflater.from() 获取到的就是一个单例服务。

​	代理模式：Retrofit 等。

### Binder 机制的了解

​	是 Android 中跨进程通信的一种方式，在使用 aidl 进行跨进程通信时，系统会为这个接口创建一个 实现类，这是实现类里面有一个 Stub 的抽象类，我们需要在服务端去实现这个抽象类，进行自己的逻辑处理。

​	这个 Stub 就是 Binder 类。在跨进程通信的时候，会判断服务是否是别的进程，如果不是，就会直接进行调用。否则就会调用代理类然后挂起当前线程，然后进行跨进程通信。所以尽量不要再主线程进行跨进程操作。当然也可以使用 o...关键字，具体名字忘了。

### Https 实现思路

客户端发起请求，然后会通过 tcp 进行连接，给服务器发送消息，服务器返回签名数据，其中包含了证书签名，证书厂家的信息。客户端使用公钥对证书进行验证，接着拿到厂家的一些信息，然后根据系统内部的根证书进行验证，验证成功后就说明服务端可以信任，然后双方就会商讨加密方式等，商讨完成后就会进行网络请求。

相对于 Http，https 更加的安全，但是安全的同时也损失了一些性能。并且 https 是密文传输，但是效率比较低。

### 有做过那些优化工作，内存优化，卡顿优化，启动优化，apk体积优化。

内存优化：对图片进行优化，如果图片是本地的且比较大，可以使用第三方工具进行压缩和处理，或者是使用 glide 进行处理；从根本上解决内存泄漏，溢出等问题，在写项目的时候，就要注意到那些地方可能会发生内存泄漏，溢出等问题，并进行排查，从根本上解决问题，在某个功能或者模块写完后，对其进行测试，查看是否有内存泄漏的情况，可以使用 as  自带的工具，也可以使用一些第三方的库，使用起来也非常好用。

卡顿优化：卡顿一般情况下都是在主线程干了不改干的事情，或者是内存占用的过高，如页面中加载了大量的图片，这个时候就需要对图片进行处理。还有就是避免在主线程做任何的耗时操作。

启动优化：一般情况都是在 Application 中初始化 sdk。有些人会将 比较耗时的 sdk 放在子线程进行初始化，这也算一种方式。还有在 内容提供者内部进行初始化。目前 jetpack 新推出了一个组件 startup，这个组件也是使用了内容提供者进行初始化 sdk，但是它使用比较简单，并且只需要一个 内容提供者即可，在内部可以自定义初始化的顺序。缺点是需要创建大量的类。如果 需要初始化的sdk 越多，需要创建的类就会越多。

apk 体积优化：apk 打包完成后，对 其进行分析，看一下到底是啥地方占用的比较大。如果图片占用比较大，就需要将 图片进行压缩处理，然后在打包。还有就是尽量使用依赖的方式来集成第三方库，有些 jar 包，还有 so 库会占用比较大的空间。还有进行混淆等。

// https://mp.weixin.qq.com/s/AvODMv5ulJ782McnewDAQg

### 单例模式为啥要双重判断

- 如果去掉第一个判断，当获取单例的时候，就会直接进入代码块中，这时，如果有其他线程也在获取单例，然而拿不到锁，只能等待。每次获取单例的时候都需要进入同步代码块中，导致性能变得低
- 如果去掉第二个，无法保证单例对象只被创建一次。

android 中的数据存储方式

- 本地存储
- 数据库存储
- sp 存储
- 网络存储

