## 登陆和授权

登陆：一个身份认证的过程。只有你在登陆的时候输入了账号和密码，服务器确定是本人操作，才可以登陆成功，然后将一些你自己的数据返回给你。

授权：将某个权限授予你，这个权限具有一定的代表性。必须要有一个授权方，给你授权后你就会拥有某个权限，从完成一项之前做不了的东西。例如 尚方宝剑，有了这个剑，我想斩谁就斩谁。这个尚方宝剑就相当于是一个权限。其实登陆也是一个授权的过程，相当于是把我的权限授予我自己。

- Cookie 

  cookie 存储在客户端，由于 http 是无状态的，http 在请求的时候会在 header 中添加 cookie，从而可以给 http 附上状态，最常见的就是登陆状态

- session：

  会话，类似于你和一个在交谈。你怎么知道当前交谈的人是张三而不是李四呢？ 对方肯定有某种特征表明他就是张三。

  session 也是类似，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要每个客户端分配不同的 身份标识。然后客户端发请求的时候需要带上这个 ”身份标识“，服务器就知道这个请求来自于谁。

  请求过程：

  1，客户端发起请求，发送用户名密码

  2，服务器生成 sessionId，绑定用户数据存储在数据库

  3，服务器返回 sessionId 给客户端

  4，客户端使用 cookie 存储 sessionId，以后每次请求都带上 sessionId

  5，服务器收到这个 sessionId，就去数据库查找用户数据，找到了就说名验证通过

  6，服务器返回对应数据

- Token

  1，客户端发起请求，发送用户名密码

  2，服务器根据用户信息加密生成 token，用户信息包括 账号，token过期时间等，可由服务器自定义

  3，服务器把 token 返回给客户端

  4，客户端用 cookie 存储token，以后请求都带上 token

  5，服务器将 token 解密，确认用户信息是否真确，真确说明验证通过

  6，服务器返回对应数据  

-  session 和 token 的区别

  这两种都差不多，只不过验证的方式不同

  sessionId 和 用户信息相互绑定的数据存放在服务器，所以服务器随时可以让法师出去的某个 sessionId 失效，主需要重新生成一个 sessionId 然后和用户信息绑定就好了。这是保障安全的一种手段

  token 好处是节省时间和空间，服务器不需要去管理 sessionId 和 用户信息的数据库。服务器收到 token 直接解密验证就行了，不需要去数据库查找验证。但是 token 发送出去后就只能等它达到过期时间后才会失效，后台无法控制。

## TCP / IP

​	一系列协议组成的一个网络分层模型

- 为什么要分层

  理想的状态下是一对一的请求，例如发送 http 请求，服务器进行响应。

  实际上在发送请求的过程中会遇到很多的节点，最后才会到达服务器，然后服务器进行响应

  在很多情况下网络时不稳定的，在发送请求的时候在某个节点数据丢了，就只能重新发送了。但是由于数据过大，导致经常失败。本来这个请求只需啊哟 50 毫秒，结果到最后花了 2秒钟。在实际中可能会出现各种各样的问题导致网络变得非常不稳定，导致数据丢失。

  怎么解决呢：**分块传输**，将数据转化成小块，然后打上对应的标记在进行传输，如果某个块没传送成功，只需要重新传一下这个块即可。

  **由于有分块传输，所以就需要分层了**。因为应用层协议不止 http 自己，还有 ftp，smtp 等。因为他们都有这种需求。所以就抽出来一层，让这层只做包的分发。

- 传输层 TCP，UDP 

  **抽出来的这层就叫做传输层**：应用层要发送数据，就会将数据发送到传输层，然后在进行分块传输，如果某个块传输失败，在传输层重新传一下就可以了。传输层可以保证网络的稳定。

  问题：但是不是所有的数据都需要重传，例如在吃鸡的时候卡了两秒，数据没法出去，别人也没接收到，接着不卡了，那你觉得卡了两秒中的数据还需要重新传吗？肯定不需要呀。。

  解决：这种可以使用 UDP 进行传输，没有重传机制，刚好可以避免这个问题

  由于 TCP 和 UDP 都是需要传输到服务器，都有这种网络的需求，所以再抽出来一层，传输层就不用负责传输了。只是将数据切一下，分成块给下一层即可。

- IP(网络层)

  这一层中将数据块直接传给目标地址，只负责传，不会管任何东西，如 数据块的联系，是否传成功也不管。

  IP 层不是真正传数据的，而是用来寻址的，寻找路由器，这是 IP 层做的。

  到现在传输的流程大致如下：

  应用层将数据给 TCP ，

  TCP 将数据进行分块，并编号，如 1,2,3,4 分成了四块。

  接着 TCP 将块直接给 IP 层，让他传数据。

  IP 将四个块按顺序进行传输，传输成功后会进行确认，如 1 号传输成功，IP 就会通知上层，然后 TCP 就知道 1 号传输成功了。接着 2 好传输成功，进行通知。接着 3 号传输失败，没有通知。最后四号也传输成功，然后进行通知，TCP 发现 3 号没有传输成功，就会重新让 IP 传输 3 号。传输成功后就会通知 TCP 传输完成了。

  IP 会把数据发送到对方的 TCP 层中，TCP 将消息按顺序组成，然后就通知应用层你收到一个消息。

- 数据链路层

  以太网，WI-Fi

## TCP 连接

- 连接

  通信双方建立确认可以通信，不会讲对方的消息丢弃，即为 建立建立

- TCP 连接的建立与关闭

  TCP 连接的建立：三次握手

  1，请求方：我要给你发消息了

  2，服务器：我知道了，我也要给你发了

  3，请求方：我知道你要给我发了

  TCP 连接的关闭：四次挥手

  1，请求方：我不在给你发消息了

  2，服务器：好的，我知道了

  3，服务器：我不在给你发消息了

  4，请求方：好的，我知道了

- 长连接

  - 为什么要长连接

    因为移动网络并不在 internet 中，而是在运营商的内网中，并不具有正真的公网 IP ，因此当 某个 TCP 连接在一段时间不通信后，网关会出于网络性能的考虑关闭 TCP 连接和公网连接通道，导致这个 TCP 不能接收到外部通信消息。

  - 长连接的实现方式

    心跳，即在一定间隔的时间内，使用 TCP 连接发送超短毫无意义的消息来让网关不能将自己定义为 空闲连接。从而防止网关将自己的连接关闭。

## Https

- 定义

  在 HTTP 之下增加的一个安全层，用于保障 HTTP 的加密传输

- 本质

  在客户端和服务器之间协商出一个对称秘钥，每次发送消息之前将内容加密，收到消息后进行解密。从而达到内容的加密传输。

- 为什么不直接使用非对称加密？

  太慢了。

- 流程

  1，客户端请求建立 TLS 连接，这个过程是通过 tcp 的。

  2，服务器发回证书

  3，客户端验证服务器证书

  4，客户端信任服务器后，和服务器协商对称秘钥

  5，使用对称秘钥开始通信(到这里才使用的是 https，之前都是 tcp )
  
- HTTPS 连接

  1，客户端发送一个连接消息，并附加上 TLS 版本，Cipher suite(可以接受的 对称，非对称和 hash 算法)，随机数。

  2，服务器接收到的消息后，从 cipher suite 中获取出一种算法。返回收到,并附加随机数。(这个时候双方就已经确定了 TLS 版本，对称和非对称以及hash的算法，并且服务器有客户端的随机数和自己的随机数，客户端有服务端的随机数和自己的随机数）

  3，服务器返回证书。其中有两点很重要，1，告诉客户端我的公钥，2，让客户端验证我的身份是真实的

  4，拿到服务器真实公钥，使用公钥加密一个信息（Pre-master Secret (随机数)），发送到服务器。接着两边都会有三个随机数，分别是客户端随机数，服务端随机数，Pre-master Secret。然后客户端和服务端就会通过这三个值和一个算法获取到一个新的值1，名字就是 Master Secret。

  然后就可以通过这个 Master Secret 计算秘钥了。其实这个秘钥是四个东西(实际上是6个，只不过其中两个没用)，客户端加密密钥，服务端加密密钥，客户端 MAC Secret ,服务端 MAC Secret。

  这四个东西客户端和服务端都会包含。其中 MAC Secret 是用来验证身份的工具。这四个东西最终就是用来做加密和验证身份的。

  5，客户端告诉服务器要开始加密通信了

  6，客户端发送：将上面所有的操作使用服务端密钥进行加密，并且使用 MAC 进行一个相当于签名的操作，然后发送给服务器。

  7，验证消息，然后发送消息：我要开始加密通信了

  8，服务器：将上面所有的操作使用服务端密钥进行加密，并且使用 MAC 进行一个相当于签名的操作，然后发送给服务器.

在 Android 中使用

- 正常情况

  直接使用

- 什么时候会不行

  - 用的是自签名证书（例如只用于内网的 https）

  - 证书信息不全，缺乏证书机构信息
  - 手机操作系统较旧，没有安装最新加入的根证书